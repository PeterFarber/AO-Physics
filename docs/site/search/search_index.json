{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview This documentation provides an overview of the core components of the physics simulation system: World , Body , and various Constraints . Each component plays a crucial role in defining the behavior and interactions of objects within the simulation. Table of Contents World Body Constraints Example Usage World The World object represents the simulation environment, managing global settings and the overall state of the simulation. It handles physical properties such as gravity, body limits, and simulation time. For detailed information on how to configure and use the World , refer to the World documentation . Body The Body object represents an individual object within the simulation. Bodies have physical attributes like mass, position, and velocity, and they interact with other bodies through forces and constraints. For detailed information on the properties and methods available for Body , refer to the Body documentation . Constraints Constraints define relationships and restrictions between bodies, simulating various physical joints and connections. They determine how bodies move relative to each other and the types of interactions that can occur. For detailed information on the different types of constraints and their configurations, refer to the Constraints documentation . Examples To help you get started with the physics simulation system, here are some examples showcasing different aspects of its usage: Basic : This example demonstrates how to initialize the simulation environment, create and configure bodies, apply physical motions, and update and retrieve simulation states. It covers the fundamental concepts and operations of the physics simulation system. Note This example does not include using Constraints Attention More Coming Soon... Feel free to explore these examples to gain a better understanding of how to use the physics simulation system in your projects. For more detailed usage and information on each component, please consult the respective documentation linked in the table of contents. IMPORTANT AO Physics is still in its early stage of development...","title":"Overview"},{"location":"#overview","text":"This documentation provides an overview of the core components of the physics simulation system: World , Body , and various Constraints . Each component plays a crucial role in defining the behavior and interactions of objects within the simulation.","title":"Overview"},{"location":"#table-of-contents","text":"World Body Constraints Example Usage","title":"Table of Contents"},{"location":"#world","text":"The World object represents the simulation environment, managing global settings and the overall state of the simulation. It handles physical properties such as gravity, body limits, and simulation time. For detailed information on how to configure and use the World , refer to the World documentation .","title":"World"},{"location":"#body","text":"The Body object represents an individual object within the simulation. Bodies have physical attributes like mass, position, and velocity, and they interact with other bodies through forces and constraints. For detailed information on the properties and methods available for Body , refer to the Body documentation .","title":"Body"},{"location":"#constraints","text":"Constraints define relationships and restrictions between bodies, simulating various physical joints and connections. They determine how bodies move relative to each other and the types of interactions that can occur. For detailed information on the different types of constraints and their configurations, refer to the Constraints documentation .","title":"Constraints"},{"location":"#examples","text":"To help you get started with the physics simulation system, here are some examples showcasing different aspects of its usage: Basic : This example demonstrates how to initialize the simulation environment, create and configure bodies, apply physical motions, and update and retrieve simulation states. It covers the fundamental concepts and operations of the physics simulation system. Note This example does not include using Constraints Attention More Coming Soon... Feel free to explore these examples to gain a better understanding of how to use the physics simulation system in your projects. For more detailed usage and information on each component, please consult the respective documentation linked in the table of contents. IMPORTANT AO Physics is still in its early stage of development...","title":"Examples"},{"location":"body/","text":"Body The Body class represents a physical object within the simulation, allowing for various configurations and interactions. Table of Contents Introduction Settings Functions Add - Add's the Body to the World Remove - Remove the Body from the World SetData - Set custom Data on the Body GetData - Get the custom set Data from the Body SetLinearVelocity - Sets the Linear Velocity of the Body SetAngularVelocity - Adds to the Linear Velocity of the Body AddLinearVelocity - Sets the Angular Velocity of the Body AddAngularVelocity - Adds to the Angular Velocity of the Body AddForce - Adds Force of the Body AddTorque - Adds Torque of the Body AddImpulse - Adds Impulse of the Body CastRay - Casts a ray from a starting point in a specified direction and returns information about any intersected objects. Example: Creating and Configuring a Sphere Body Settings The following properties define the state and behavior of a body object in the simulation. Property Type Description Default Value data table Custom JSON data associated with the body. {} position table The position of the body in 3D space. { 0, 0, 0 } rotation table The rotation of the body as a quaternion (x, y, z, w). { 0, 0, 0, 1 } linearVelocity table The linear velocity of the { 0, 0, 0 } angularVelocity table The angular velocity of the { 0, 0, 0 } motionType string The motion type of the Options are \"Dynamic\" , \"Static\" , \"Kinematic\" . \"Dynamic\" motionQuality string The motion quality of the Options are \"Discrete\" , \"LinearCast\" . \"Discrete\" layer string The collision layer of the Options are \"MOVING\" , \"NON_MOVING\" . \"MOVING\" shape string The shape of the Options are \"Box\" , \"Sphere\" , \"Capsule\" , \"Cylinder\" . \"Box\" activate boolean Determines if the body is active. true enhancedInternalEdgeRemoval boolean Determines if enhanced internal edge removal is enabled. false allowSleeping boolean Allows the body to enter a sleeping state when not in motion. true friction number The friction coefficient of the 0.2 restitution number The restitution (bounciness) of the 0.0 linearDamping number The linear damping applied to the 0.05 angularDamping number The angular damping applied to the 0.05 maxLinearVelocity number The maximum linear velocity of the 500.0 maxAngularVelocity number The maximum angular velocity of the 0.25 * \u03c0 * 60.0 gravityFactor number The factor by which gravity affects the 1.0 size table The size of the body (used for Box shape). { 1, 1, 1 } radius number The radius of the body (used for Sphere and Capsule shapes). 0.5 height number The height of the body (used for Capsule and Cylinder shapes). 2.0 Functions Add Adds the body to the physics simulation and assigns it a unique id . Example Usage body:Add() This function serializes the body's properties and adds it to the simulation, generating and assigning a unique identifier (id) for the body. This id is used in subsequent operations to reference this specific body within the physics system. Remove Removes the body from the physics simulation using its unique id . Example Usage body:Remove() This function removes the body associated with the given id from the simulation. Once removed, the body's id will no longer be valid for operations within the physics system. SetData Allows setting custom JSON data to be associated with a body within the physics simulation without affecting its actual properties. Example Usage body:SetData({\"customKey\": \"customValue\"}) This function stores the provided JSON data with the body in the physics simulation but does not modify the body's physical properties or behavior. It can be used to attach metadata or other non-physical information to the body for tracking or reference purposes. GetData Retrieves the custom JSON data associated with a body within the physics simulation. Example Usage local data = body:GetData() This function returns the JSON data that was previously set using SetData . The retrieved data does not affect the body's physical properties or behavior and is typically used for accessing metadata or other non-physical information associated with the body. SetLinearVelocity Sets the linear velocity of the body. Parameters velocity ( table {number, number, number} ): A table representing the x, y, and z components of the linear velocity. Example Usage local velocity = {1.0, 2.0, 0.0} body:SetLinearVelocity(velocity) This function sets the body's linear velocity to the specified vector components, directly altering its motion in the simulation. SetAngularVelocity Sets the angular velocity of the body. Parameters velocity ( table {number, number, number} ): A table representing the x, y, and z components of the angular velocity. Example Usage local angularVelocity = {0.1, 0.2, 0.3} body:SetAngularVelocity(angularVelocity) This function sets the body's angular velocity to the specified vector components, directly affecting its rotational motion in the simulation. AddLinearVelocity Adds to the current linear velocity of the body. Parameters velocity ( table {number, number, number} ): A table representing the x, y, and z components of the velocity to add. Example Usage local velocity = {1.0, 0.5, 0.0} body:AddLinearVelocity(velocity) This function modifies the body's current linear velocity by adding the specified velocity vector components to it. AddAngularVelocity Adds to the current angular velocity of the body. Parameters velocity ( table {number, number, number} ): A table representing the x, y, and z components of the angular velocity to add. Example Usage local angularVelocity = {0.1, 0.2, 0.3} body:AddAngularVelocity(angularVelocity) This function adjusts the body's current angular velocity by adding the specified velocity vector components to it, effectively changing the body's rotational motion. AddForce Applies a force to the body. Parameters force ( table {number, number, number} ): A table representing the x, y, and z components of the force to apply. Example Usage local force = {10.0, 0.0, 0.0} body:AddForce(force) This function applies a force to the body, influencing its movement and interaction with other bodies. AddTorque Applies a torque to the body. Parameters torque ( table {number, number, number} ): A table representing the x, y, and z components of the torque to apply. Example Usage local torque = {0.0, 5.0, 0.0} body:AddTorque(torque) This function applies a torque to the body, affecting its rotational motion. AddImpulse Applies an impulse to the body. Parameters impulse ( table {number, number, number} ): A table representing the x, y, and z components of the impulse to apply. Example Usage local impulse = {0.0, 10.0, 0.0} body:AddImpulse(impulse) This function applies an impulse to the body, resulting in a sudden change in its velocity. CastRay Casts a ray from the body's current position in a specified direction to detect collisions. Parameters direction ( table {number, number, number} ): A table representing the x, y, and z components of the direction vector for the ray. Returns result ( table ): A table containing the result of the ray cast, including: hit ( boolean ): Whether the ray hit something. hitPoint ( table {number, number, number} ): The point of collision. hitBodyID ( number ): The ID of the body that was hit. Example Usage local direction = {0.0, 0.0, -1.0} local result = body:CastRay(direction) if result.hit then print(\"Hit at:\", result.hitPoint[1], result.hitPoint[2], result.hitPoint[3]) end This function casts a ray from the body's current position in the specified direction and returns information about any collisions detected. Example This example demonstrates how to create a sphere body, configure its properties, and set its linear velocity. Code local sphere = AOP:Body() -- Create a new body instance. sphere.shape = \"Sphere\" -- Set the shape of the body to \"Sphere\". sphere.radius = 0.5 -- Set the radius of the sphere to 0.5 units. sphere.position = { -3.0, 1, 0.0 } -- Position the sphere at coordinates (-3.0, 1, 0.0). sphere.layer = \"MOVING\" -- Assign the body to the \"MOVING\" layer. sphere.activate = true -- Activate the body in the simulation. sphere:Add() -- Add the body to the physics simulation. sphere:SetLinearVelocity({ 0.0, 0.0, 5.0 }) -- Set the linear velocity of the body to (0.0, 0.0, 5.0). Description Create a Body Instance: AOP:Body() creates a new body instance. Set Shape: The shape property is set to \"Sphere\" , defining the body's shape. Set Radius: The radius property is set to 0.5 , defining the sphere's size. Set Position: The position property sets the sphere's location in 3D space. Set Layer: The layer property is set to \"MOVING\" , indicating the body is part of the moving layer. Activate the Body: The activate property is set to true to enable the body in the simulation. Add to Simulation: The Add method is called to add the body to the physics simulation. Set Linear Velocity: The SetLinearVelocity method is used to set the body's linear velocity to (0.0, 0.0, 5.0) , influencing its movement in the simulation.","title":"Body"},{"location":"body/#body","text":"The Body class represents a physical object within the simulation, allowing for various configurations and interactions.","title":"Body"},{"location":"body/#table-of-contents","text":"Introduction Settings Functions Add - Add's the Body to the World Remove - Remove the Body from the World SetData - Set custom Data on the Body GetData - Get the custom set Data from the Body SetLinearVelocity - Sets the Linear Velocity of the Body SetAngularVelocity - Adds to the Linear Velocity of the Body AddLinearVelocity - Sets the Angular Velocity of the Body AddAngularVelocity - Adds to the Angular Velocity of the Body AddForce - Adds Force of the Body AddTorque - Adds Torque of the Body AddImpulse - Adds Impulse of the Body CastRay - Casts a ray from a starting point in a specified direction and returns information about any intersected objects. Example: Creating and Configuring a Sphere Body","title":"Table of Contents"},{"location":"body/#settings","text":"The following properties define the state and behavior of a body object in the simulation. Property Type Description Default Value data table Custom JSON data associated with the body. {} position table The position of the body in 3D space. { 0, 0, 0 } rotation table The rotation of the body as a quaternion (x, y, z, w). { 0, 0, 0, 1 } linearVelocity table The linear velocity of the { 0, 0, 0 } angularVelocity table The angular velocity of the { 0, 0, 0 } motionType string The motion type of the Options are \"Dynamic\" , \"Static\" , \"Kinematic\" . \"Dynamic\" motionQuality string The motion quality of the Options are \"Discrete\" , \"LinearCast\" . \"Discrete\" layer string The collision layer of the Options are \"MOVING\" , \"NON_MOVING\" . \"MOVING\" shape string The shape of the Options are \"Box\" , \"Sphere\" , \"Capsule\" , \"Cylinder\" . \"Box\" activate boolean Determines if the body is active. true enhancedInternalEdgeRemoval boolean Determines if enhanced internal edge removal is enabled. false allowSleeping boolean Allows the body to enter a sleeping state when not in motion. true friction number The friction coefficient of the 0.2 restitution number The restitution (bounciness) of the 0.0 linearDamping number The linear damping applied to the 0.05 angularDamping number The angular damping applied to the 0.05 maxLinearVelocity number The maximum linear velocity of the 500.0 maxAngularVelocity number The maximum angular velocity of the 0.25 * \u03c0 * 60.0 gravityFactor number The factor by which gravity affects the 1.0 size table The size of the body (used for Box shape). { 1, 1, 1 } radius number The radius of the body (used for Sphere and Capsule shapes). 0.5 height number The height of the body (used for Capsule and Cylinder shapes). 2.0","title":"Settings"},{"location":"body/#functions","text":"","title":"Functions"},{"location":"body/#add","text":"Adds the body to the physics simulation and assigns it a unique id .","title":"Add"},{"location":"body/#example-usage","text":"body:Add() This function serializes the body's properties and adds it to the simulation, generating and assigning a unique identifier (id) for the body. This id is used in subsequent operations to reference this specific body within the physics system.","title":"Example Usage"},{"location":"body/#remove","text":"Removes the body from the physics simulation using its unique id .","title":"Remove"},{"location":"body/#example-usage_1","text":"body:Remove() This function removes the body associated with the given id from the simulation. Once removed, the body's id will no longer be valid for operations within the physics system.","title":"Example Usage"},{"location":"body/#setdata","text":"Allows setting custom JSON data to be associated with a body within the physics simulation without affecting its actual properties.","title":"SetData"},{"location":"body/#example-usage_2","text":"body:SetData({\"customKey\": \"customValue\"}) This function stores the provided JSON data with the body in the physics simulation but does not modify the body's physical properties or behavior. It can be used to attach metadata or other non-physical information to the body for tracking or reference purposes.","title":"Example Usage"},{"location":"body/#getdata","text":"Retrieves the custom JSON data associated with a body within the physics simulation.","title":"GetData"},{"location":"body/#example-usage_3","text":"local data = body:GetData() This function returns the JSON data that was previously set using SetData . The retrieved data does not affect the body's physical properties or behavior and is typically used for accessing metadata or other non-physical information associated with the body.","title":"Example Usage"},{"location":"body/#setlinearvelocity","text":"Sets the linear velocity of the body.","title":"SetLinearVelocity"},{"location":"body/#parameters","text":"velocity ( table {number, number, number} ): A table representing the x, y, and z components of the linear velocity.","title":"Parameters"},{"location":"body/#example-usage_4","text":"local velocity = {1.0, 2.0, 0.0} body:SetLinearVelocity(velocity) This function sets the body's linear velocity to the specified vector components, directly altering its motion in the simulation.","title":"Example Usage"},{"location":"body/#setangularvelocity","text":"Sets the angular velocity of the body.","title":"SetAngularVelocity"},{"location":"body/#parameters_1","text":"velocity ( table {number, number, number} ): A table representing the x, y, and z components of the angular velocity.","title":"Parameters"},{"location":"body/#example-usage_5","text":"local angularVelocity = {0.1, 0.2, 0.3} body:SetAngularVelocity(angularVelocity) This function sets the body's angular velocity to the specified vector components, directly affecting its rotational motion in the simulation.","title":"Example Usage"},{"location":"body/#addlinearvelocity","text":"Adds to the current linear velocity of the body.","title":"AddLinearVelocity"},{"location":"body/#parameters_2","text":"velocity ( table {number, number, number} ): A table representing the x, y, and z components of the velocity to add.","title":"Parameters"},{"location":"body/#example-usage_6","text":"local velocity = {1.0, 0.5, 0.0} body:AddLinearVelocity(velocity) This function modifies the body's current linear velocity by adding the specified velocity vector components to it.","title":"Example Usage"},{"location":"body/#addangularvelocity","text":"Adds to the current angular velocity of the body.","title":"AddAngularVelocity"},{"location":"body/#parameters_3","text":"velocity ( table {number, number, number} ): A table representing the x, y, and z components of the angular velocity to add.","title":"Parameters"},{"location":"body/#example-usage_7","text":"local angularVelocity = {0.1, 0.2, 0.3} body:AddAngularVelocity(angularVelocity) This function adjusts the body's current angular velocity by adding the specified velocity vector components to it, effectively changing the body's rotational motion.","title":"Example Usage"},{"location":"body/#addforce","text":"Applies a force to the body.","title":"AddForce"},{"location":"body/#parameters_4","text":"force ( table {number, number, number} ): A table representing the x, y, and z components of the force to apply.","title":"Parameters"},{"location":"body/#example-usage_8","text":"local force = {10.0, 0.0, 0.0} body:AddForce(force) This function applies a force to the body, influencing its movement and interaction with other bodies.","title":"Example Usage"},{"location":"body/#addtorque","text":"Applies a torque to the body.","title":"AddTorque"},{"location":"body/#parameters_5","text":"torque ( table {number, number, number} ): A table representing the x, y, and z components of the torque to apply.","title":"Parameters"},{"location":"body/#example-usage_9","text":"local torque = {0.0, 5.0, 0.0} body:AddTorque(torque) This function applies a torque to the body, affecting its rotational motion.","title":"Example Usage"},{"location":"body/#addimpulse","text":"Applies an impulse to the body.","title":"AddImpulse"},{"location":"body/#parameters_6","text":"impulse ( table {number, number, number} ): A table representing the x, y, and z components of the impulse to apply.","title":"Parameters"},{"location":"body/#example-usage_10","text":"local impulse = {0.0, 10.0, 0.0} body:AddImpulse(impulse) This function applies an impulse to the body, resulting in a sudden change in its velocity.","title":"Example Usage"},{"location":"body/#castray","text":"Casts a ray from the body's current position in a specified direction to detect collisions.","title":"CastRay"},{"location":"body/#parameters_7","text":"direction ( table {number, number, number} ): A table representing the x, y, and z components of the direction vector for the ray.","title":"Parameters"},{"location":"body/#returns","text":"result ( table ): A table containing the result of the ray cast, including: hit ( boolean ): Whether the ray hit something. hitPoint ( table {number, number, number} ): The point of collision. hitBodyID ( number ): The ID of the body that was hit.","title":"Returns"},{"location":"body/#example-usage_11","text":"local direction = {0.0, 0.0, -1.0} local result = body:CastRay(direction) if result.hit then print(\"Hit at:\", result.hitPoint[1], result.hitPoint[2], result.hitPoint[3]) end This function casts a ray from the body's current position in the specified direction and returns information about any collisions detected.","title":"Example Usage"},{"location":"body/#example","text":"This example demonstrates how to create a sphere body, configure its properties, and set its linear velocity.","title":"Example"},{"location":"body/#code","text":"local sphere = AOP:Body() -- Create a new body instance. sphere.shape = \"Sphere\" -- Set the shape of the body to \"Sphere\". sphere.radius = 0.5 -- Set the radius of the sphere to 0.5 units. sphere.position = { -3.0, 1, 0.0 } -- Position the sphere at coordinates (-3.0, 1, 0.0). sphere.layer = \"MOVING\" -- Assign the body to the \"MOVING\" layer. sphere.activate = true -- Activate the body in the simulation. sphere:Add() -- Add the body to the physics simulation. sphere:SetLinearVelocity({ 0.0, 0.0, 5.0 }) -- Set the linear velocity of the body to (0.0, 0.0, 5.0).","title":"Code"},{"location":"body/#description","text":"Create a Body Instance: AOP:Body() creates a new body instance. Set Shape: The shape property is set to \"Sphere\" , defining the body's shape. Set Radius: The radius property is set to 0.5 , defining the sphere's size. Set Position: The position property sets the sphere's location in 3D space. Set Layer: The layer property is set to \"MOVING\" , indicating the body is part of the moving layer. Activate the Body: The activate property is set to true to enable the body in the simulation. Add to Simulation: The Add method is called to add the body to the physics simulation. Set Linear Velocity: The SetLinearVelocity method is used to set the body's linear velocity to (0.0, 0.0, 5.0) , influencing its movement in the simulation.","title":"Description"},{"location":"character/","text":"Character IMPORTANT Coming Soon!!!","title":"Character"},{"location":"character/#character","text":"IMPORTANT Coming Soon!!!","title":"Character"},{"location":"constraint/","text":"Constraints The Constraints class defines various constraints used to govern the relationships between bodies in the simulation. Each constraint type has specific properties and methods to manage and apply the constraints. Table of Contents Introduction Constraint Types Hinge Constraint Slider Constraint Pulley Constraint Point Constraint Gear Constraint Fixed Constraint Distance Constraint Cone Constraint Methods Constraint Types Hinge Constraint Represents a hinge-like connection between two bodies. Properties Property Type Description Default Value type string Type of constraint. \"Hinge\" space string Space in which the constraint is defined. \"WorldSpace\" point1 table The hinge's attachment point on the first body. { 0, 0, 0 } hingeAxis1 table The axis of rotation for the first body. { 0, 1, 0 } normalAxis1 table The normal axis for the first body. { 1, 0, 0 } point2 table The hinge's attachment point on the second body. { 0, 0, 0 } hingeAxis2 table The axis of rotation for the second body. { 0, 1, 0 } normalAxis2 table The normal axis for the second body. { 1, 0, 0 } limitsMin number Minimum angle limit for the hinge. -180.0 limitsMax number Maximum angle limit for the hinge. 180.0 maxFrictionTorque number Maximum friction torque for the hinge. 0.0 limitsSpringSettings table Spring settings for the angle limits. { mode = \"FrequencyAndDamping\", frequency = 0.0, stiffness = 0.0, damping = 0.0 } motorSettings table Motor settings for the hinge. { frequency = 0.0, damping = 0.0 } motorState string State of the motor. \"Off\" targetAngularVelocity number Target angular velocity of the hinge. 0.0 targetAngle number Target angle of the hinge. 0.0 Slider Constraint Represents a slider-like connection that allows movement along a single axis. Properties Property Type Description Default Value type string Type of constraint. \"Slider\" space string Space in which the constraint is defined. \"WorldSpace\" autoDetectPoint boolean Whether the attachment point is auto-detected. false point1 table The slider's attachment point on the first body. { 0, 0, 0 } sliderAxis1 table The axis along which the slider moves for the first body. { 1, 0, 0 } normalAxis1 table The normal axis for the first body. { 0, 1, 0 } point2 table The slider's attachment point on the second body. { 0, 0, 0 } sliderAxis2 table The axis along which the slider moves for the second body. { 1, 0, 0 } normalAxis2 table The normal axis for the second body. { 0, 1, 0 } limitsMin number Minimum movement limit for the slider. -3.40282347e+38 limitsMax number Maximum movement limit for the slider. 3.40282347e+38 maxFrictionForce number Maximum friction force for the slider. 0.0 limitsSpringSettings table Spring settings for the movement limits. { mode = \"FrequencyAndDamping\", frequency = 0.0, stiffness = 0.0, damping = 0.0 } motorSettings table Motor settings for the slider. { frequency = 0.0, damping = 0.0 } Pulley Constraint Represents a pulley system connecting two bodies. Properties Property Type Description Default Value type string Type of constraint. \"Pulley\" space string Space in which the constraint is defined. \"WorldSpace\" bodyPoint1 table Attachment point on the first body. { 0, 0, 0 } fixedPoint1 table Fixed point in the world for the first pulley. { 0, 0, 0 } bodyPoint2 table Attachment point on the second body. { 0, 0, 0 } fixedPoint2 table Fixed point in the world for the second pulley. { 0, 0, 0 } ratio number Ratio of the pulley system. 1.0 minLength number Minimum length of the pulley. 0.0 maxLength number Maximum length of the pulley. 0.0 Point Constraint Represents a point-to-point connection between two bodies. Properties Property Type Description Default Value type string Type of constraint. \"Point\" space string Space in which the constraint is defined. \"WorldSpace\" point1 table The point of attachment on the first body. { 0, 0, 0 } point2 table The point of attachment on the second body. { 0, 0, 0 } Gear Constraint Represents a gear-like connection between two bodies. Properties Property Type Description Default Value type string Type of constraint. \"Gear\" space string Space in which the constraint is defined. \"WorldSpace\" numTeeth1 number Number of teeth on the first gear. 1 numTeeth2 number Number of teeth on the second gear. 1 hingeAxis1 table The axis of rotation for the first gear. { 1, 0, 0 } hingeAxis2 table The axis of rotation for the second gear. | { 1, 0, 0 } | | ratio | number | Gear ratio between the two gears. | 1.0 | Fixed Constraint Represents a fixed connection between two bodies. Properties Property Type Description Default Value type string Type of constraint. \"Fixed\" space string Space in which the constraint is defined. \"WorldSpace\" point1 table The attachment point on the first body. { 0, 0, 0 } axisX1 table The X axis direction for the first body. { 0, 1, 0 } axisY1 table The Y axis direction for the first body. { 1, 0, 0 } point2 table The attachment point on the second body. { 0, 0, 0 } axisX2 table The X axis direction for the second body. { 0, 1, 0 } axisY2 table The Y axis direction for the second body. { 1, 0, 0 } Distance Constraint Represents a distance constraint between two bodies. Properties Property Type Description Default Value type string Type of constraint. \"Distance\" space string Space in which the constraint is defined. \"WorldSpace\" point1 table The attachment point on the first body. { 0, 0, 0 } point2 table The attachment point on the second body. { 0, 0, 0 } minDistance number Minimum distance between the bodies. -1.0 maxDistance number Maximum distance between the bodies. -1.0 limitsSpringSettings table Spring settings for distance limits. { mode = \"FrequencyAndDamping\", frequency = 0.0, stiffness = 0.0, damping = 0.0 } Cone Constraint Represents a cone-like connection allowing rotation within a cone. Properties Property Type Description Default Value type l string Type of constraint. \"Cone\" space string Space in which the constraint is defined. \"WorldSpace\" point1 table The point of attachment on the first body. { 0, 0, 0 } twistAxis1 table The twist axis for the first body. { 0, 1, 0 } point2 table The point of attachment on the second body. { 0, 0, 0 } twistAxis2 table The twist axis for the second body. { 0, 1, 0 } halfConeAngle number Half of the cone angle defining the constraint. 0.0 Methods Add(Body1, Body2) Adds the constraint between two bodies. Parameters body1 ( object ): The first body to connect. body2 ( object ): The second body to connect. Returns id ( number ): The unique identifier for the created constraint. This method creates and adds the constraint between the two specified bodies, returning the unique ID of the created constraint. Remove() Removes the specified constraint from the physics simulation.","title":"Constraint"},{"location":"constraint/#constraints","text":"The Constraints class defines various constraints used to govern the relationships between bodies in the simulation. Each constraint type has specific properties and methods to manage and apply the constraints.","title":"Constraints"},{"location":"constraint/#table-of-contents","text":"Introduction Constraint Types Hinge Constraint Slider Constraint Pulley Constraint Point Constraint Gear Constraint Fixed Constraint Distance Constraint Cone Constraint Methods","title":"Table of Contents"},{"location":"constraint/#constraint-types","text":"","title":"Constraint Types"},{"location":"constraint/#hinge-constraint","text":"Represents a hinge-like connection between two bodies.","title":"Hinge Constraint"},{"location":"constraint/#properties","text":"Property Type Description Default Value type string Type of constraint. \"Hinge\" space string Space in which the constraint is defined. \"WorldSpace\" point1 table The hinge's attachment point on the first body. { 0, 0, 0 } hingeAxis1 table The axis of rotation for the first body. { 0, 1, 0 } normalAxis1 table The normal axis for the first body. { 1, 0, 0 } point2 table The hinge's attachment point on the second body. { 0, 0, 0 } hingeAxis2 table The axis of rotation for the second body. { 0, 1, 0 } normalAxis2 table The normal axis for the second body. { 1, 0, 0 } limitsMin number Minimum angle limit for the hinge. -180.0 limitsMax number Maximum angle limit for the hinge. 180.0 maxFrictionTorque number Maximum friction torque for the hinge. 0.0 limitsSpringSettings table Spring settings for the angle limits. { mode = \"FrequencyAndDamping\", frequency = 0.0, stiffness = 0.0, damping = 0.0 } motorSettings table Motor settings for the hinge. { frequency = 0.0, damping = 0.0 } motorState string State of the motor. \"Off\" targetAngularVelocity number Target angular velocity of the hinge. 0.0 targetAngle number Target angle of the hinge. 0.0","title":"Properties"},{"location":"constraint/#slider-constraint","text":"Represents a slider-like connection that allows movement along a single axis.","title":"Slider Constraint"},{"location":"constraint/#properties_1","text":"Property Type Description Default Value type string Type of constraint. \"Slider\" space string Space in which the constraint is defined. \"WorldSpace\" autoDetectPoint boolean Whether the attachment point is auto-detected. false point1 table The slider's attachment point on the first body. { 0, 0, 0 } sliderAxis1 table The axis along which the slider moves for the first body. { 1, 0, 0 } normalAxis1 table The normal axis for the first body. { 0, 1, 0 } point2 table The slider's attachment point on the second body. { 0, 0, 0 } sliderAxis2 table The axis along which the slider moves for the second body. { 1, 0, 0 } normalAxis2 table The normal axis for the second body. { 0, 1, 0 } limitsMin number Minimum movement limit for the slider. -3.40282347e+38 limitsMax number Maximum movement limit for the slider. 3.40282347e+38 maxFrictionForce number Maximum friction force for the slider. 0.0 limitsSpringSettings table Spring settings for the movement limits. { mode = \"FrequencyAndDamping\", frequency = 0.0, stiffness = 0.0, damping = 0.0 } motorSettings table Motor settings for the slider. { frequency = 0.0, damping = 0.0 }","title":"Properties"},{"location":"constraint/#pulley-constraint","text":"Represents a pulley system connecting two bodies.","title":"Pulley Constraint"},{"location":"constraint/#properties_2","text":"Property Type Description Default Value type string Type of constraint. \"Pulley\" space string Space in which the constraint is defined. \"WorldSpace\" bodyPoint1 table Attachment point on the first body. { 0, 0, 0 } fixedPoint1 table Fixed point in the world for the first pulley. { 0, 0, 0 } bodyPoint2 table Attachment point on the second body. { 0, 0, 0 } fixedPoint2 table Fixed point in the world for the second pulley. { 0, 0, 0 } ratio number Ratio of the pulley system. 1.0 minLength number Minimum length of the pulley. 0.0 maxLength number Maximum length of the pulley. 0.0","title":"Properties"},{"location":"constraint/#point-constraint","text":"Represents a point-to-point connection between two bodies.","title":"Point Constraint"},{"location":"constraint/#properties_3","text":"Property Type Description Default Value type string Type of constraint. \"Point\" space string Space in which the constraint is defined. \"WorldSpace\" point1 table The point of attachment on the first body. { 0, 0, 0 } point2 table The point of attachment on the second body. { 0, 0, 0 }","title":"Properties"},{"location":"constraint/#gear-constraint","text":"Represents a gear-like connection between two bodies.","title":"Gear Constraint"},{"location":"constraint/#properties_4","text":"Property Type Description Default Value type string Type of constraint. \"Gear\" space string Space in which the constraint is defined. \"WorldSpace\" numTeeth1 number Number of teeth on the first gear. 1 numTeeth2 number Number of teeth on the second gear. 1 hingeAxis1 table The axis of rotation for the first gear. { 1, 0, 0 } hingeAxis2 table The axis of rotation for the second gear. | { 1, 0, 0 } | | ratio | number | Gear ratio between the two gears. | 1.0 |","title":"Properties"},{"location":"constraint/#fixed-constraint","text":"Represents a fixed connection between two bodies.","title":"Fixed Constraint"},{"location":"constraint/#properties_5","text":"Property Type Description Default Value type string Type of constraint. \"Fixed\" space string Space in which the constraint is defined. \"WorldSpace\" point1 table The attachment point on the first body. { 0, 0, 0 } axisX1 table The X axis direction for the first body. { 0, 1, 0 } axisY1 table The Y axis direction for the first body. { 1, 0, 0 } point2 table The attachment point on the second body. { 0, 0, 0 } axisX2 table The X axis direction for the second body. { 0, 1, 0 } axisY2 table The Y axis direction for the second body. { 1, 0, 0 }","title":"Properties"},{"location":"constraint/#distance-constraint","text":"Represents a distance constraint between two bodies.","title":"Distance Constraint"},{"location":"constraint/#properties_6","text":"Property Type Description Default Value type string Type of constraint. \"Distance\" space string Space in which the constraint is defined. \"WorldSpace\" point1 table The attachment point on the first body. { 0, 0, 0 } point2 table The attachment point on the second body. { 0, 0, 0 } minDistance number Minimum distance between the bodies. -1.0 maxDistance number Maximum distance between the bodies. -1.0 limitsSpringSettings table Spring settings for distance limits. { mode = \"FrequencyAndDamping\", frequency = 0.0, stiffness = 0.0, damping = 0.0 }","title":"Properties"},{"location":"constraint/#cone-constraint","text":"Represents a cone-like connection allowing rotation within a cone.","title":"Cone Constraint"},{"location":"constraint/#properties_7","text":"Property Type Description Default Value type l string Type of constraint. \"Cone\" space string Space in which the constraint is defined. \"WorldSpace\" point1 table The point of attachment on the first body. { 0, 0, 0 } twistAxis1 table The twist axis for the first body. { 0, 1, 0 } point2 table The point of attachment on the second body. { 0, 0, 0 } twistAxis2 table The twist axis for the second body. { 0, 1, 0 } halfConeAngle number Half of the cone angle defining the constraint. 0.0","title":"Properties"},{"location":"constraint/#methods","text":"","title":"Methods"},{"location":"constraint/#addbody1-body2","text":"Adds the constraint between two bodies.","title":"Add(Body1, Body2)"},{"location":"constraint/#parameters","text":"body1 ( object ): The first body to connect. body2 ( object ): The second body to connect.","title":"Parameters"},{"location":"constraint/#returns","text":"id ( number ): The unique identifier for the created constraint. This method creates and adds the constraint between the two specified bodies, returning the unique ID of the created constraint.","title":"Returns"},{"location":"constraint/#remove","text":"Removes the specified constraint from the physics simulation.","title":"Remove()"},{"location":"lua_module/","text":"Lua Module Note The Lua module in this documentation provides a convenient interface for interacting with the AO Physics library, which is implemented in C++. The module allows users to create and manipulate physics bodies, apply forces and constraints, and simulate physics interactions. To use the Lua module, you need to require the \"aop\" module, which internally loads the C++ AO Physics library. Additionally, you will need to import other Lua modules such as \"json\" and \"class\" for JSON encoding and class creation, respectively. Overall, the Lua module provides a high-level interface for working with the AO Physics library, making it easier to integrate physics simulations into Lua-based applications. _AOP = require(\"aop\") local json = require('json') local class = require('class') AOPModule = class(function(aop) end) AOP = AOPModule() function AOP:Body() local body = {} body.id = -1 body.data = {} -- Used to store custom data body.position = { 0, 0, 0 } body.rotation = { 0, 0, 0, 1 } body.linearVelocity = { 0, 0, 0 } body.angularVelocity = { 0, 0, 0 } body.motionType = \"Dynamic\" -- \"Dynamic\" | \"Static\" | \"Kinematic\" body.motionQuality = \"Discrete\" -- \"Discrete\" | \"LinearCast\" body.layer = \"MOVING\" -- \"MOVING\" | \"NON_MOVING\" body.shape = \"Box\" -- \"Box\" | \"Sphere\" | \"Capsule\" | \"Cylinder\" body.activate = true body.enhancedInternalEdgeRemoval = false body.allowSleeping = true body.friction = 0.2 body.restitution = 0.0 body.linearDamping = 0.05 body.angularDamping = 0.05 body.maxLinearVelocity = 500.0 body.maxAngularVelocity = 0.25 * 3.14159265359 * 60.0 body.gravityFactor = 1.0 body.size = { 1, 1, 1 } body.radius = 0.5 body.height = 2.0 function body:Add() self.data = json.encode(self.data); self.id = math.floor(_AOP.add_body(json.encode(self))) self.data = json.decode(self.data); end function body:SetData(data) _AOP.set_data_body(self.id, json.encode(data)) end function body:GetData() return json.decode(_AOP.get_data_body(self.id)) end function body:SetLinearVelocity(velocity --[[{x, y, z}]]) _AOP.set_linear_velocity(self.id, velocity[1], velocity[2], velocity[3]) end function body:SetAngularVelocity(velocity --[[{x, y, z}]]) _AOP.set_angular_velocity(self.id, velocity[1], velocity[2], velocity[3]) end function body:AddLinearVelocity(velocity --[[{x, y, z}]]) _AOP.add_linear_velocity(self.id, velocity[1], velocity[2], velocity[3]) end function body:AddAngularVelocity(velocity --[[{x, y, z}]]) _AOP.add_angular_velocity(self.id, velocity[1], velocity[2], velocity[3]) end function body:AddForce(force --[[{x, y, z}]]) _AOP.add_force(self.id, force[1], force[2], force[3]) end function body:AddTorque(torque --[[{x, y, z}]]) _AOP.add_torque(self.id, torque[1], torque[2], torque[3]) end function body:AddImpulse(impulse --[[{x, y, z}]]) _AOP.add_impulse(self.id, impulse[1], impulse[2], impulse[3]) end function body:CastRay(direction --[[{x, y, z}]]) local hit = json.decode(_AOP.cast_ray(self.id, direction[1], direction[2], direction[3])) local result = { hit = hit.hit, hitPoint = hit.hitPoint, hitBodyID = hit.hitBodyID } return result end function body:Remove() _AOP.remove_body(self.id) end return body; end function AOP:ConstraintHinge() local hingeConstraint = {}; hingeConstraint.type = \"Hinge\" hingeConstraint.space = \"WorldSpace\" -- \"WorldSpace\" | \"LocalToBodyCOM\" hingeConstraint.point1 = { 0, 0, 0 } -- [float] x, y, z hingeConstraint.hingeAxis1 = { 0, 1, 0 } -- [float] x, y, z hingeConstraint.normalAxis1 = { 1, 0, 0 } -- [float] x, y, z hingeConstraint.point2 = { 0, 0, 0 } -- [float] x, y, z hingeConstraint.hingeAxis2 = { 0, 1, 0 } -- [float] x, y, z hingeConstraint.normalAxis2 = { 1, 0, 0 } -- [float] x, y, z hingeConstraint.limitsMin = -180.0 -- [Degrees] hingeConstraint.limitsMax = 180 -- [float] Degrees hingeConstraint.maxFrictionTorque = 0.0 hingeConstraint.limitsSpringSettings = { mode = \"FrequencyAndDamping\", -- [string] \"FrequencyAndDamping\" | \"StiffnessAndDamping\" frequency = 0.0, stiffness = 0.0, damping = 0.0 } hingeConstraint.motorSettings = { frequency = 0.0, damping = 0.0 } hingeConstraint.motorState = \"Off\" -- \"Off\" | \"Velocity\" | \"Position\" hingeConstraint.targetAngularVelocity = 0.0 hingeConstraint.targetAngle = 0.0 function hingeConstraint:Add(body1, body2) self.body1ID = body1.id self.body2ID = body2.id self.id = _AOP.add_constraint(json.encode(self)) return self.id end function hingeConstraint:Remove() _AOP.remove_constraint(self.id) end return hingeConstraint; end function AOP:ConstraintSlider() local sliderConstraint = {}; sliderConstraint.type = \"Slider\" sliderConstraint.space = \"WorldSpace\" -- \"WorldSpace\" | \"LocalToBodyCOM\" sliderConstraint.autoDetectPoint = false sliderConstraint.point1 = { 0, 0, 0 } -- [float] x, y, z sliderConstraint.sliderAxis1 = { 1, 0, 0 } -- [float] x, y, z sliderConstraint.normalAxis1 = { 0, 1, 0 } -- [float] x, y, z sliderConstraint.point2 = { 0, 0, 0 } -- [float] x, y, z sliderConstraint.sliderAxis2 = { 1, 0, 0 } -- [float] x, y, z sliderConstraint.normalAxis2 = { 0, 1, 0 } -- [float] x, y, z sliderConstraint.limitsMin = -3.40282347e+38 sliderConstraint.limitsMax = 3.40282347e+38 sliderConstraint.maxFrictionForce = 0.0 sliderConstraint.limitsSpringSettings = { mode = \"FrequencyAndDamping\", -- [string] \"FrequencyAndDamping\" | \"StiffnessAndDamping\" frequency = 0.0, stiffness = 0.0, damping = 0.0 } sliderConstraint.motorSettings = { frequency = 0.0, damping = 0.0 } function sliderConstraint:Add(body1, body2) self.body1ID = body1.id self.body2ID = body2.id self.id = _AOP.add_constraint(json.encode(self)) return self.id end function sliderConstraint:Remove() _AOP.remove_constraint(self.id) end return sliderConstraint; end function AOP:ConstraintPulley() local pulleyConstraint = {}; pulleyConstraint.type = \"Pulley\" pulleyConstraint.space = \"WorldSpace\" -- \"WorldSpace\" | \"LocalToBodyCOM\" pulleyConstraint.bodyPoint1 = { 0, 0, 0 } -- [float] x, y, z pulleyConstraint.fixedPoint1 = { 0, 0, 0 } -- [float] x, y, z pulleyConstraint.bodyPoint2 = { 0, 0, 0 } -- [float] x, y, z pulleyConstraint.fixedPoint2 = { 0, 0, 0 } -- [float] x, y, z pulleyConstraint.ratio = 1.0 pulleyConstraint.minLength = 0.0 pulleyConstraint.maxLength = 0.0 function pulleyConstraint:Add(body1, body2) self.body1ID = body1.id self.body2ID = body2.id self.id = _AOP.add_constraint(json.encode(self)) return self.id end function pulleyConstraint:Remove() _AOP.remove_constraint(self.id) end return pulleyConstraint; end function AOP:ConstraintPoint() local pointConstraint = {}; pointConstraint.type = \"Point\" pointConstraint.space = \"WorldSpace\" -- \"WorldSpace\" | \"LocalToBodyCOM\" pointConstraint.point1 = { 0, 0, 0 } -- [float] x, y, z pointConstraint.point2 = { 0, 0, 0 } -- [float] x, y, z function pointConstraint:Add(body1, body2) self.body1ID = body1.id self.body2ID = body2.id self.id = _AOP.add_constraint(json.encode(self)) return self.id end function pointConstraint:Remove() _AOP.remove_constraint(self.id) end return pointConstraint; end function AOP:ConstraintGear() local gearConstraint = {}; gearConstraint.type = \"Gear\" gearConstraint.space = \"WorldSpace\" -- \"WorldSpace\" | \"LocalToBodyCOM\" gearConstraint.numTeeth1 = 1 gearConstraint.numTeeth2 = 1 gearConstraint.hingeAxis1 = { 1, 0, 0 } -- [float] x, y, z gearConstraint.hingeAxis2 = { 1, 0, 0 } -- [float] x, y, z gearConstraint.ratio = 1.0 function gearConstraint:Add(body1, body2) self.body1ID = body1.id self.body2ID = body2.id self.id = _AOP.add_constraint(json.encode(self)) return self.id end function gearConstraint:Remove() _AOP.remove_constraint(self.id) end return gearConstraint; end function AOP:ConstraintFixed() local fixedConstraint = {}; fixedConstraint.type = \"Fixed\" fixedConstraint.space = \"WorldSpace\" -- \"WorldSpace\" | \"LocalToBodyCOM\" fixedConstraint.point1 = { 0, 0, 0 } -- [float] x, y, z fixedConstraint.axisX1 = { 0, 1, 0 } -- [float] x, y, z fixedConstraint.axisY1 = { 1, 0, 0 } -- [float] x, y, z fixedConstraint.point2 = { 0, 0, 0 } -- [float] x, y, z fixedConstraint.axisX2 = { 0, 1, 0 } -- [float] x, y, z fixedConstraint.axisY2 = { 1, 0, 0 } -- [float] x, y, z function fixedConstraint:Add(body1, body2) self.body1ID = body1.id self.body2ID = body2.id self.id = _AOP.add_constraint(json.encode(self)) return self.id end function fixedConstraint:Remove() _AOP.remove_constraint(self.id) end return fixedConstraint; end function AOP:ConstraintDistance() local distanceConstraint = {}; distanceConstraint.type = \"Distance\" distanceConstraint.space = \"WorldSpace\" -- \"WorldSpace\" | \"LocalToBodyCOM\" distanceConstraint.point1 = { 0, 0, 0 } -- [float] x, y, z distanceConstraint.point2 = { 0, 0, 0 } -- [float] x, y, z distanceConstraint.minDistance = -1.0 distanceConstraint.maxDistance = -1.0 distanceConstraint.limitsSpringSettings = { mode = \"FrequencyAndDamping\", -- [string] \"FrequencyAndDamping\" | \"StiffnessAndDamping\" frequency = 0.0, stiffness = 0.0, damping = 0.0 } function distanceConstraint:Add(body1, body2) self.body1ID = body1.id self.body2ID = body2.id self.id = _AOP.add_constraint(json.encode(self)) return self.id end function distanceConstraint:Remove() _AOP.remove_constraint(self.id) end return distanceConstraint; end function AOP:ConstraintCone() local coneConstraint = {}; coneConstraint.type = \"Cone\" coneConstraint.space = \"WorldSpace\" -- \"WorldSpace\" | \"LocalToBodyCOM\" coneConstraint.point1 = { 0, 0, 0 } -- [float] x, y, z coneConstraint.twistAxis1 = { 0, 1, 0 } -- [float] x, y, z coneConstraint.point2 = { 0, 0, 0 } -- [float] x, y, z coneConstraint.twistAxis2 = { 0, 1, 0 } -- [float] x, y, z coneConstraint.halfConeAngle = 0.0 function coneConstraint:Add(body1, body2) self.body1ID = body1.id self.body2ID = body2.id self.id = _AOP.add_constraint(json.encode(self)) return self.id end function coneConstraint:Remove() _AOP.remove_constraint(self.id) end return coneConstraint; end function AOP:Character() local character = { canMoveWhileJumping = false, speed = 1.0, sprintSpeed = 2.0, jumpForce = 6.0, heightStanding = 1.35, radiusStanding = 0.3, maxSlopeAngle = 45.0, friction = 0.5, mass = 0.0, gravityFactor = 1.0, position = { 0, 0, 0 }, rotation = { 0, 0, 0, 1 }, up = { 0, 1, 0 }, layer = \"MOVING\", -- \"MOVING\" | \"NON_MOVING\" activate = true } character.id = -1; function character:Add() self.id = math.floor(_AOP.add_character(json.encode(self))) return self.id; end function character:Input() local input = { x = 0, z = 0, jump = false, sprint = false, crouch = false } return input end function character:SendInput(data) local msg = { id = self.id, input = { data.x, data.z }, jump = data.jump, sprint = data.sprint, crouch = data.crouch } _AOP.move_character(json.encode(msg)) end return character; end function AOP:World() local world = { gravity = { 0.0, -9.81, 0.0 }, timeBeforeSleep = 0.5, allowSleeping = true, maxBodies = 1024, numBodyMutexes = 0, maxBodyPairs = 1024, maxContactConstraints = 1024 } world.WorldStates = {} function world:Create() _AOP.world_create(json.encode(self)) end function world:Update(steps, deltaTime) _AOP.world_update(steps, deltaTime) end function world:GetState() local worldState = _AOP.get_world_state() table.insert(self.WorldStates, worldState) return worldState end function world:GetStates() local state = [[{ \"worldStates\": []] for i = 1, #self.WorldStates do state = state .. self.WorldStates[i] .. \",\" end state = state:sub(1, #state - 1) state = state .. \"]}\" self.WorldStates = {} return state end function world:Destroy() _AOP.world_destroy() end return world; end return AOP","title":"Lua Module"},{"location":"lua_module/#lua-module","text":"Note The Lua module in this documentation provides a convenient interface for interacting with the AO Physics library, which is implemented in C++. The module allows users to create and manipulate physics bodies, apply forces and constraints, and simulate physics interactions. To use the Lua module, you need to require the \"aop\" module, which internally loads the C++ AO Physics library. Additionally, you will need to import other Lua modules such as \"json\" and \"class\" for JSON encoding and class creation, respectively. Overall, the Lua module provides a high-level interface for working with the AO Physics library, making it easier to integrate physics simulations into Lua-based applications. _AOP = require(\"aop\") local json = require('json') local class = require('class') AOPModule = class(function(aop) end) AOP = AOPModule() function AOP:Body() local body = {} body.id = -1 body.data = {} -- Used to store custom data body.position = { 0, 0, 0 } body.rotation = { 0, 0, 0, 1 } body.linearVelocity = { 0, 0, 0 } body.angularVelocity = { 0, 0, 0 } body.motionType = \"Dynamic\" -- \"Dynamic\" | \"Static\" | \"Kinematic\" body.motionQuality = \"Discrete\" -- \"Discrete\" | \"LinearCast\" body.layer = \"MOVING\" -- \"MOVING\" | \"NON_MOVING\" body.shape = \"Box\" -- \"Box\" | \"Sphere\" | \"Capsule\" | \"Cylinder\" body.activate = true body.enhancedInternalEdgeRemoval = false body.allowSleeping = true body.friction = 0.2 body.restitution = 0.0 body.linearDamping = 0.05 body.angularDamping = 0.05 body.maxLinearVelocity = 500.0 body.maxAngularVelocity = 0.25 * 3.14159265359 * 60.0 body.gravityFactor = 1.0 body.size = { 1, 1, 1 } body.radius = 0.5 body.height = 2.0 function body:Add() self.data = json.encode(self.data); self.id = math.floor(_AOP.add_body(json.encode(self))) self.data = json.decode(self.data); end function body:SetData(data) _AOP.set_data_body(self.id, json.encode(data)) end function body:GetData() return json.decode(_AOP.get_data_body(self.id)) end function body:SetLinearVelocity(velocity --[[{x, y, z}]]) _AOP.set_linear_velocity(self.id, velocity[1], velocity[2], velocity[3]) end function body:SetAngularVelocity(velocity --[[{x, y, z}]]) _AOP.set_angular_velocity(self.id, velocity[1], velocity[2], velocity[3]) end function body:AddLinearVelocity(velocity --[[{x, y, z}]]) _AOP.add_linear_velocity(self.id, velocity[1], velocity[2], velocity[3]) end function body:AddAngularVelocity(velocity --[[{x, y, z}]]) _AOP.add_angular_velocity(self.id, velocity[1], velocity[2], velocity[3]) end function body:AddForce(force --[[{x, y, z}]]) _AOP.add_force(self.id, force[1], force[2], force[3]) end function body:AddTorque(torque --[[{x, y, z}]]) _AOP.add_torque(self.id, torque[1], torque[2], torque[3]) end function body:AddImpulse(impulse --[[{x, y, z}]]) _AOP.add_impulse(self.id, impulse[1], impulse[2], impulse[3]) end function body:CastRay(direction --[[{x, y, z}]]) local hit = json.decode(_AOP.cast_ray(self.id, direction[1], direction[2], direction[3])) local result = { hit = hit.hit, hitPoint = hit.hitPoint, hitBodyID = hit.hitBodyID } return result end function body:Remove() _AOP.remove_body(self.id) end return body; end function AOP:ConstraintHinge() local hingeConstraint = {}; hingeConstraint.type = \"Hinge\" hingeConstraint.space = \"WorldSpace\" -- \"WorldSpace\" | \"LocalToBodyCOM\" hingeConstraint.point1 = { 0, 0, 0 } -- [float] x, y, z hingeConstraint.hingeAxis1 = { 0, 1, 0 } -- [float] x, y, z hingeConstraint.normalAxis1 = { 1, 0, 0 } -- [float] x, y, z hingeConstraint.point2 = { 0, 0, 0 } -- [float] x, y, z hingeConstraint.hingeAxis2 = { 0, 1, 0 } -- [float] x, y, z hingeConstraint.normalAxis2 = { 1, 0, 0 } -- [float] x, y, z hingeConstraint.limitsMin = -180.0 -- [Degrees] hingeConstraint.limitsMax = 180 -- [float] Degrees hingeConstraint.maxFrictionTorque = 0.0 hingeConstraint.limitsSpringSettings = { mode = \"FrequencyAndDamping\", -- [string] \"FrequencyAndDamping\" | \"StiffnessAndDamping\" frequency = 0.0, stiffness = 0.0, damping = 0.0 } hingeConstraint.motorSettings = { frequency = 0.0, damping = 0.0 } hingeConstraint.motorState = \"Off\" -- \"Off\" | \"Velocity\" | \"Position\" hingeConstraint.targetAngularVelocity = 0.0 hingeConstraint.targetAngle = 0.0 function hingeConstraint:Add(body1, body2) self.body1ID = body1.id self.body2ID = body2.id self.id = _AOP.add_constraint(json.encode(self)) return self.id end function hingeConstraint:Remove() _AOP.remove_constraint(self.id) end return hingeConstraint; end function AOP:ConstraintSlider() local sliderConstraint = {}; sliderConstraint.type = \"Slider\" sliderConstraint.space = \"WorldSpace\" -- \"WorldSpace\" | \"LocalToBodyCOM\" sliderConstraint.autoDetectPoint = false sliderConstraint.point1 = { 0, 0, 0 } -- [float] x, y, z sliderConstraint.sliderAxis1 = { 1, 0, 0 } -- [float] x, y, z sliderConstraint.normalAxis1 = { 0, 1, 0 } -- [float] x, y, z sliderConstraint.point2 = { 0, 0, 0 } -- [float] x, y, z sliderConstraint.sliderAxis2 = { 1, 0, 0 } -- [float] x, y, z sliderConstraint.normalAxis2 = { 0, 1, 0 } -- [float] x, y, z sliderConstraint.limitsMin = -3.40282347e+38 sliderConstraint.limitsMax = 3.40282347e+38 sliderConstraint.maxFrictionForce = 0.0 sliderConstraint.limitsSpringSettings = { mode = \"FrequencyAndDamping\", -- [string] \"FrequencyAndDamping\" | \"StiffnessAndDamping\" frequency = 0.0, stiffness = 0.0, damping = 0.0 } sliderConstraint.motorSettings = { frequency = 0.0, damping = 0.0 } function sliderConstraint:Add(body1, body2) self.body1ID = body1.id self.body2ID = body2.id self.id = _AOP.add_constraint(json.encode(self)) return self.id end function sliderConstraint:Remove() _AOP.remove_constraint(self.id) end return sliderConstraint; end function AOP:ConstraintPulley() local pulleyConstraint = {}; pulleyConstraint.type = \"Pulley\" pulleyConstraint.space = \"WorldSpace\" -- \"WorldSpace\" | \"LocalToBodyCOM\" pulleyConstraint.bodyPoint1 = { 0, 0, 0 } -- [float] x, y, z pulleyConstraint.fixedPoint1 = { 0, 0, 0 } -- [float] x, y, z pulleyConstraint.bodyPoint2 = { 0, 0, 0 } -- [float] x, y, z pulleyConstraint.fixedPoint2 = { 0, 0, 0 } -- [float] x, y, z pulleyConstraint.ratio = 1.0 pulleyConstraint.minLength = 0.0 pulleyConstraint.maxLength = 0.0 function pulleyConstraint:Add(body1, body2) self.body1ID = body1.id self.body2ID = body2.id self.id = _AOP.add_constraint(json.encode(self)) return self.id end function pulleyConstraint:Remove() _AOP.remove_constraint(self.id) end return pulleyConstraint; end function AOP:ConstraintPoint() local pointConstraint = {}; pointConstraint.type = \"Point\" pointConstraint.space = \"WorldSpace\" -- \"WorldSpace\" | \"LocalToBodyCOM\" pointConstraint.point1 = { 0, 0, 0 } -- [float] x, y, z pointConstraint.point2 = { 0, 0, 0 } -- [float] x, y, z function pointConstraint:Add(body1, body2) self.body1ID = body1.id self.body2ID = body2.id self.id = _AOP.add_constraint(json.encode(self)) return self.id end function pointConstraint:Remove() _AOP.remove_constraint(self.id) end return pointConstraint; end function AOP:ConstraintGear() local gearConstraint = {}; gearConstraint.type = \"Gear\" gearConstraint.space = \"WorldSpace\" -- \"WorldSpace\" | \"LocalToBodyCOM\" gearConstraint.numTeeth1 = 1 gearConstraint.numTeeth2 = 1 gearConstraint.hingeAxis1 = { 1, 0, 0 } -- [float] x, y, z gearConstraint.hingeAxis2 = { 1, 0, 0 } -- [float] x, y, z gearConstraint.ratio = 1.0 function gearConstraint:Add(body1, body2) self.body1ID = body1.id self.body2ID = body2.id self.id = _AOP.add_constraint(json.encode(self)) return self.id end function gearConstraint:Remove() _AOP.remove_constraint(self.id) end return gearConstraint; end function AOP:ConstraintFixed() local fixedConstraint = {}; fixedConstraint.type = \"Fixed\" fixedConstraint.space = \"WorldSpace\" -- \"WorldSpace\" | \"LocalToBodyCOM\" fixedConstraint.point1 = { 0, 0, 0 } -- [float] x, y, z fixedConstraint.axisX1 = { 0, 1, 0 } -- [float] x, y, z fixedConstraint.axisY1 = { 1, 0, 0 } -- [float] x, y, z fixedConstraint.point2 = { 0, 0, 0 } -- [float] x, y, z fixedConstraint.axisX2 = { 0, 1, 0 } -- [float] x, y, z fixedConstraint.axisY2 = { 1, 0, 0 } -- [float] x, y, z function fixedConstraint:Add(body1, body2) self.body1ID = body1.id self.body2ID = body2.id self.id = _AOP.add_constraint(json.encode(self)) return self.id end function fixedConstraint:Remove() _AOP.remove_constraint(self.id) end return fixedConstraint; end function AOP:ConstraintDistance() local distanceConstraint = {}; distanceConstraint.type = \"Distance\" distanceConstraint.space = \"WorldSpace\" -- \"WorldSpace\" | \"LocalToBodyCOM\" distanceConstraint.point1 = { 0, 0, 0 } -- [float] x, y, z distanceConstraint.point2 = { 0, 0, 0 } -- [float] x, y, z distanceConstraint.minDistance = -1.0 distanceConstraint.maxDistance = -1.0 distanceConstraint.limitsSpringSettings = { mode = \"FrequencyAndDamping\", -- [string] \"FrequencyAndDamping\" | \"StiffnessAndDamping\" frequency = 0.0, stiffness = 0.0, damping = 0.0 } function distanceConstraint:Add(body1, body2) self.body1ID = body1.id self.body2ID = body2.id self.id = _AOP.add_constraint(json.encode(self)) return self.id end function distanceConstraint:Remove() _AOP.remove_constraint(self.id) end return distanceConstraint; end function AOP:ConstraintCone() local coneConstraint = {}; coneConstraint.type = \"Cone\" coneConstraint.space = \"WorldSpace\" -- \"WorldSpace\" | \"LocalToBodyCOM\" coneConstraint.point1 = { 0, 0, 0 } -- [float] x, y, z coneConstraint.twistAxis1 = { 0, 1, 0 } -- [float] x, y, z coneConstraint.point2 = { 0, 0, 0 } -- [float] x, y, z coneConstraint.twistAxis2 = { 0, 1, 0 } -- [float] x, y, z coneConstraint.halfConeAngle = 0.0 function coneConstraint:Add(body1, body2) self.body1ID = body1.id self.body2ID = body2.id self.id = _AOP.add_constraint(json.encode(self)) return self.id end function coneConstraint:Remove() _AOP.remove_constraint(self.id) end return coneConstraint; end function AOP:Character() local character = { canMoveWhileJumping = false, speed = 1.0, sprintSpeed = 2.0, jumpForce = 6.0, heightStanding = 1.35, radiusStanding = 0.3, maxSlopeAngle = 45.0, friction = 0.5, mass = 0.0, gravityFactor = 1.0, position = { 0, 0, 0 }, rotation = { 0, 0, 0, 1 }, up = { 0, 1, 0 }, layer = \"MOVING\", -- \"MOVING\" | \"NON_MOVING\" activate = true } character.id = -1; function character:Add() self.id = math.floor(_AOP.add_character(json.encode(self))) return self.id; end function character:Input() local input = { x = 0, z = 0, jump = false, sprint = false, crouch = false } return input end function character:SendInput(data) local msg = { id = self.id, input = { data.x, data.z }, jump = data.jump, sprint = data.sprint, crouch = data.crouch } _AOP.move_character(json.encode(msg)) end return character; end function AOP:World() local world = { gravity = { 0.0, -9.81, 0.0 }, timeBeforeSleep = 0.5, allowSleeping = true, maxBodies = 1024, numBodyMutexes = 0, maxBodyPairs = 1024, maxContactConstraints = 1024 } world.WorldStates = {} function world:Create() _AOP.world_create(json.encode(self)) end function world:Update(steps, deltaTime) _AOP.world_update(steps, deltaTime) end function world:GetState() local worldState = _AOP.get_world_state() table.insert(self.WorldStates, worldState) return worldState end function world:GetStates() local state = [[{ \"worldStates\": []] for i = 1, #self.WorldStates do state = state .. self.WorldStates[i] .. \",\" end state = state:sub(1, #state - 1) state = state .. \"]}\" self.WorldStates = {} return state end function world:Destroy() _AOP.world_destroy() end return world; end return AOP","title":"Lua Module"},{"location":"setup/","text":"Setup IMPORTANT Coming Soon!!!","title":"Setup"},{"location":"setup/#setup","text":"IMPORTANT Coming Soon!!!","title":"Setup"},{"location":"world/","text":"World The World class represents the entire simulation environment, handling physical interactions and managing the state of the simulation. Table of Contents Introduction Settings Functions Create - Initializes the World Update - Updates the World simulation GetState - Retrieves the current state of the World GetStates - Retrieves the history of World states Destroy - Destroys the World Example: Creating and Configuring a World Settings The following properties define the configuration and behavior of the simulation world. Property Type Description Default Value gravity table The gravitational force affecting the world. { 0.0, -9.81, 0.0 } timeBeforeSleep number Time before bodies go to sleep. 0.5 allowSleeping boolean Whether bodies are allowed to sleep when inactive. true maxBodies number Maximum number of bodies in the world. 1024 numBodyMutexes number Number of mutexes used for body operations. 0 maxBodyPairs number Maximum number of body pairs for collision detection. 1024 maxContactConstraints number Maximum number of contact constraints. 1024 Functions Create Initializes the world with the specified settings. Example Usage local world = AOP:World() world:Create() This function creates the world instance in the simulation using the current settings. Update Updates the world simulation by a specified number of steps and time delta. Parameters steps ( number ): The number of simulation steps to advance. deltaTime ( number ): The time increment for each simulation step. Example Usage world:Update(1, 0.016) This function advances the simulation by the given number of steps and time increment, updating the world state accordingly. GetState Retrieves the current state of the world. Returns state ( table ): The current state of the world. Example Usage local state = world:GetState() print(state) This function returns the current state of the world and logs it for analysis or debugging. GetStates Retrieves the history of world states since the last call. Returns stateHistory ( string ): A JSON string representing the history of world states. Example Usage local stateHistory = world:GetStates() print(stateHistory) This function returns a JSON string containing all the world states recorded since the last call to GetStates , and clears the history. Destroy Destroys the world, cleaning up resources and ending the simulation. Example Usage world:Destroy() This function destroys the world instance, releasing all associated resources and stopping the simulation. Example This example demonstrates how to create a world, configure its properties, and update its simulation. Code local world = AOP:World() -- Create a new world instance. world.gravity = {0.0, -9.81, 0.0} -- Set gravity to Earth's gravity. world.timeBeforeSleep = 1.0 -- Set time before bodies go to sleep to 1 second. world.maxBodies = 2048 -- Set maximum number of bodies to 2048. world:Create() -- Initialize the world with these settings. world:Update(1, 0.016) -- Advance the simulation by one step (0.016 seconds). local currentState = world:GetState() -- Retrieve the current state of the world. print(\"Current State:\", currentState) local stateHistory = world:GetStates() -- Retrieve and clear the history of world states. print(\"State History:\", stateHistory) world:Destroy() -- Destroy the world and clean up resources. Description Create a World Instance: AOP:World() creates a new world instance with default settings. Set Properties: Modify properties such as gravity , timeBeforeSleep , and maxBodies to configure the world. Initialize World: The Create method is used to initialize the world with the configured settings. Advance Simulation: The Update method advances the simulation by one step, updating the world state. Retrieve Current State: The GetState method retrieves the current state of the world. Retrieve State History: The GetStates method retrieves and clears the history of world states. Destroy World: The Destroy method is used to clean up resources and end the simulation.","title":"World"},{"location":"world/#world","text":"The World class represents the entire simulation environment, handling physical interactions and managing the state of the simulation.","title":"World"},{"location":"world/#table-of-contents","text":"Introduction Settings Functions Create - Initializes the World Update - Updates the World simulation GetState - Retrieves the current state of the World GetStates - Retrieves the history of World states Destroy - Destroys the World Example: Creating and Configuring a World","title":"Table of Contents"},{"location":"world/#settings","text":"The following properties define the configuration and behavior of the simulation world. Property Type Description Default Value gravity table The gravitational force affecting the world. { 0.0, -9.81, 0.0 } timeBeforeSleep number Time before bodies go to sleep. 0.5 allowSleeping boolean Whether bodies are allowed to sleep when inactive. true maxBodies number Maximum number of bodies in the world. 1024 numBodyMutexes number Number of mutexes used for body operations. 0 maxBodyPairs number Maximum number of body pairs for collision detection. 1024 maxContactConstraints number Maximum number of contact constraints. 1024","title":"Settings"},{"location":"world/#functions","text":"","title":"Functions"},{"location":"world/#create","text":"Initializes the world with the specified settings.","title":"Create"},{"location":"world/#example-usage","text":"local world = AOP:World() world:Create() This function creates the world instance in the simulation using the current settings.","title":"Example Usage"},{"location":"world/#update","text":"Updates the world simulation by a specified number of steps and time delta.","title":"Update"},{"location":"world/#parameters","text":"steps ( number ): The number of simulation steps to advance. deltaTime ( number ): The time increment for each simulation step.","title":"Parameters"},{"location":"world/#example-usage_1","text":"world:Update(1, 0.016) This function advances the simulation by the given number of steps and time increment, updating the world state accordingly.","title":"Example Usage"},{"location":"world/#getstate","text":"Retrieves the current state of the world.","title":"GetState"},{"location":"world/#returns","text":"state ( table ): The current state of the world.","title":"Returns"},{"location":"world/#example-usage_2","text":"local state = world:GetState() print(state) This function returns the current state of the world and logs it for analysis or debugging.","title":"Example Usage"},{"location":"world/#getstates","text":"Retrieves the history of world states since the last call.","title":"GetStates"},{"location":"world/#returns_1","text":"stateHistory ( string ): A JSON string representing the history of world states.","title":"Returns"},{"location":"world/#example-usage_3","text":"local stateHistory = world:GetStates() print(stateHistory) This function returns a JSON string containing all the world states recorded since the last call to GetStates , and clears the history.","title":"Example Usage"},{"location":"world/#destroy","text":"Destroys the world, cleaning up resources and ending the simulation.","title":"Destroy"},{"location":"world/#example-usage_4","text":"world:Destroy() This function destroys the world instance, releasing all associated resources and stopping the simulation.","title":"Example Usage"},{"location":"world/#example","text":"This example demonstrates how to create a world, configure its properties, and update its simulation.","title":"Example"},{"location":"world/#code","text":"local world = AOP:World() -- Create a new world instance. world.gravity = {0.0, -9.81, 0.0} -- Set gravity to Earth's gravity. world.timeBeforeSleep = 1.0 -- Set time before bodies go to sleep to 1 second. world.maxBodies = 2048 -- Set maximum number of bodies to 2048. world:Create() -- Initialize the world with these settings. world:Update(1, 0.016) -- Advance the simulation by one step (0.016 seconds). local currentState = world:GetState() -- Retrieve the current state of the world. print(\"Current State:\", currentState) local stateHistory = world:GetStates() -- Retrieve and clear the history of world states. print(\"State History:\", stateHistory) world:Destroy() -- Destroy the world and clean up resources.","title":"Code"},{"location":"world/#description","text":"Create a World Instance: AOP:World() creates a new world instance with default settings. Set Properties: Modify properties such as gravity , timeBeforeSleep , and maxBodies to configure the world. Initialize World: The Create method is used to initialize the world with the configured settings. Advance Simulation: The Update method advances the simulation by one step, updating the world state. Retrieve Current State: The GetState method retrieves the current state of the world. Retrieve State History: The GetStates method retrieves and clears the history of world states. Destroy World: The Destroy method is used to clean up resources and end the simulation.","title":"Description"},{"location":"examples/basic/","text":"Basic Example This example demonstrates how to create and manage a simple simulation using AO Physics in Lua. The script sets up a world, creates multiple physical bodies with different properties and interactions, and then runs a simulation for a specified number of frames. Code Overview -- Load the AO Physics library AOP = require(\"AOP\") -- Define the number of simulation frames and the time step for each frame local framesToSimulate = 1000 local deltaTime = 1.0 / 60.0 --- Create a World --- -- Initialize a new world and create it local world = AOP:World() world:Create() --- Create a Floor --- -- Create a static floor body with a large size to act as the ground local floor = AOP:Body() floor.shape = \"Box\" -- Shape of the body floor.size = { 100.0, 1.0, 100.0 } -- Size of the box (length, width, height) floor.motionType = \"Static\" -- The body does not move floor.layer = \"NON_MOVING\" -- Layer for static objects floor.activate = false -- Do not activate this body initially floor:Add() -- Add the body to the world -- Create a dynamic sphere body and set its initial linear velocity local sphere = AOP:Body() sphere.shape = \"Sphere\" -- Shape of the body sphere.radius = 0.5 -- Radius of the sphere sphere.position = { -3.0, 1, 0.0 } -- Initial position of the sphere (x, y, z) sphere:Add() -- Add the body to the world sphere:SetLinearVelocity({ 0.0, 0.0, 5.0 }) -- Set the initial linear velocity -- Create another dynamic sphere body and apply a force local sphere2 = AOP:Body() sphere2.shape = \"Sphere\" -- Shape of the body sphere2.radius = 0.5 -- Radius of the sphere sphere2.position = { -1.0, 1, 0.0 } -- Initial position of the sphere sphere2:Add() -- Add the body to the world sphere2:AddForce({ 0.0, 0.0, 100000.0 }) -- Apply a force to the sphere -- Create a third dynamic sphere body and apply an impulse local sphere3 = AOP:Body() sphere3.shape = \"Sphere\" -- Shape of the body sphere3.radius = 0.5 -- Radius of the sphere sphere3.position = { 1.0, 1, 0.0 } -- Initial position of the sphere sphere3:Add() -- Add the body to the world sphere3:AddImpulse({ 0.0, 0.0, 1500.0 }) -- Apply an impulse to the sphere -- Create a fourth dynamic sphere body and apply torque local sphere4 = AOP:Body() sphere4.shape = \"Sphere\" -- Shape of the body sphere4.radius = 0.5 -- Radius of the sphere sphere4.position = { 3.0, 1, 0.0 } -- Initial position of the sphere sphere4:Add() -- Add the body to the world sphere4:AddTorque({ 50000.0, 0.0, 0 }) -- Apply torque to the sphere --- Update the World --- -- Simulate the world for the specified number of frames for i = 1, framesToSimulate do world:Update(1, deltaTime) -- Update the world with a single step world:GetState() -- Get the current state of the world end --- Get World States --- -- Print the states of the world after simulation print(world:GetStates()) --- Destroy the World --- -- Clean up and destroy the world to free resources world:Destroy() -- Return return \"\" Step-by-Step Breakdown Load the AO Physics Library: AOP = require(\"AOP\") Define Simulation Parameters: local framesToSimulate = 1000 local deltaTime = 1.0 / 60.0 Create a World: local world = AOP:World() world:Create() Create a Static Floor: -- Create a static floor body with a large size to act as the ground local floor = AOP:Body() -- Create a new body object floor.shape = \"Box\" -- Set the shape of the body to a box floor.size = { 100.0, 1.0, 100.0 } -- Set the size of the box (length, width, height) floor.motionType = \"Static\" -- Set the motion type of the body to static (does not move) floor.layer = \"NON_MOVING\" -- Set the layer of the body to NON_MOVING floor.activate = false -- Set the activation state of the body to false (do not activate initially) floor:Add() -- Add the body to the world Create and Configure Multiple Spheres: local sphere = AOP:Body() -- Create a new body object sphere.shape = \"Sphere\" -- Set the shape of the body to a sphere sphere.radius = 0.5 -- Set the radius of the sphere sphere.position = { -3.0, 1, 0.0 } -- Set the initial position of the sphere (x, y, z) sphere:Add() -- Add the body to the world sphere:SetLinearVelocity({ 0.0, 0.0, 5.0 }) -- Set the initial linear velocity of the sphere local sphere2 = AOP:Body() -- Create a new body object for sphere2 sphere2.shape = \"Sphere\" -- Set the shape of sphere2 to a sphere sphere2.radius = 0.5 -- Set the radius of sphere2 to 0.5 sphere2.position = { -1.0, 1, 0.0 } -- Set the initial position of sphere2 to (-1.0, 1, 0.0) sphere2:Add() -- Add sphere2 to the world sphere2:AddForce({ 0.0, 0.0, 100000.0 }) -- Apply a force of (0.0, 0.0, 100000.0) to sphere2 local sphere3 = AOP:Body() -- Create a new body object for sphere3 sphere3.shape = \"Sphere\" -- Set the shape of sphere3 to a sphere sphere3.radius = 0.5 -- Set the radius of sphere3 to 0.5 sphere3.position = { 1.0, 1, 0.0 } -- Set the initial position of sphere3 to (1.0, 1, 0.0) sphere3:Add() -- Add sphere3 to the world sphere3:AddImpulse({ 0.0, 0.0, 1500.0 }) -- Apply an impulse of (0.0, 0.0, 1500.0) to sphere3 local sphere4 = AOP:Body() -- Create a new body object for sphere4 sphere4.shape = \"Sphere\" -- Set the shape of sphere4 to a sphere sphere4.radius = 0.5 -- Set the radius of sphere4 to 0.5 sphere4.position = { 3.0, 1, 0.0 } -- Set the initial position of sphere4 to (3.0, 1, 0.0) sphere4:Add() -- Add sphere4 to the world sphere4:AddTorque({ 50000.0, 0.0, 0 }) -- Apply a torque of (50000.0, 0.0, 0) to sphere4 Run the Simulation: for i = 1, framesToSimulate do world:Update(1, deltaTime) -- Update the world with a single step world:GetState() -- Get the current state of the world end Output World States and Clean Up: -- Print the states of the world after simulation print(world:GetStates()) -- Clean up and destroy the world to free resources world:Destroy() Notes This script initializes a world and several physical bodies with different properties and forces. It simulates the world for 1000 frames, printing the world state after each frame. The simulation environment is destroyed at the end to clean up resources. For more details on the AO Physics library and its components, please refer to the AO Physics Documentation .","title":"Basic Example"},{"location":"examples/basic/#basic-example","text":"This example demonstrates how to create and manage a simple simulation using AO Physics in Lua. The script sets up a world, creates multiple physical bodies with different properties and interactions, and then runs a simulation for a specified number of frames.","title":"Basic Example"},{"location":"examples/basic/#code-overview","text":"-- Load the AO Physics library AOP = require(\"AOP\") -- Define the number of simulation frames and the time step for each frame local framesToSimulate = 1000 local deltaTime = 1.0 / 60.0 --- Create a World --- -- Initialize a new world and create it local world = AOP:World() world:Create() --- Create a Floor --- -- Create a static floor body with a large size to act as the ground local floor = AOP:Body() floor.shape = \"Box\" -- Shape of the body floor.size = { 100.0, 1.0, 100.0 } -- Size of the box (length, width, height) floor.motionType = \"Static\" -- The body does not move floor.layer = \"NON_MOVING\" -- Layer for static objects floor.activate = false -- Do not activate this body initially floor:Add() -- Add the body to the world -- Create a dynamic sphere body and set its initial linear velocity local sphere = AOP:Body() sphere.shape = \"Sphere\" -- Shape of the body sphere.radius = 0.5 -- Radius of the sphere sphere.position = { -3.0, 1, 0.0 } -- Initial position of the sphere (x, y, z) sphere:Add() -- Add the body to the world sphere:SetLinearVelocity({ 0.0, 0.0, 5.0 }) -- Set the initial linear velocity -- Create another dynamic sphere body and apply a force local sphere2 = AOP:Body() sphere2.shape = \"Sphere\" -- Shape of the body sphere2.radius = 0.5 -- Radius of the sphere sphere2.position = { -1.0, 1, 0.0 } -- Initial position of the sphere sphere2:Add() -- Add the body to the world sphere2:AddForce({ 0.0, 0.0, 100000.0 }) -- Apply a force to the sphere -- Create a third dynamic sphere body and apply an impulse local sphere3 = AOP:Body() sphere3.shape = \"Sphere\" -- Shape of the body sphere3.radius = 0.5 -- Radius of the sphere sphere3.position = { 1.0, 1, 0.0 } -- Initial position of the sphere sphere3:Add() -- Add the body to the world sphere3:AddImpulse({ 0.0, 0.0, 1500.0 }) -- Apply an impulse to the sphere -- Create a fourth dynamic sphere body and apply torque local sphere4 = AOP:Body() sphere4.shape = \"Sphere\" -- Shape of the body sphere4.radius = 0.5 -- Radius of the sphere sphere4.position = { 3.0, 1, 0.0 } -- Initial position of the sphere sphere4:Add() -- Add the body to the world sphere4:AddTorque({ 50000.0, 0.0, 0 }) -- Apply torque to the sphere --- Update the World --- -- Simulate the world for the specified number of frames for i = 1, framesToSimulate do world:Update(1, deltaTime) -- Update the world with a single step world:GetState() -- Get the current state of the world end --- Get World States --- -- Print the states of the world after simulation print(world:GetStates()) --- Destroy the World --- -- Clean up and destroy the world to free resources world:Destroy() -- Return return \"\"","title":"Code Overview"},{"location":"examples/basic/#step-by-step-breakdown","text":"Load the AO Physics Library: AOP = require(\"AOP\") Define Simulation Parameters: local framesToSimulate = 1000 local deltaTime = 1.0 / 60.0 Create a World: local world = AOP:World() world:Create() Create a Static Floor: -- Create a static floor body with a large size to act as the ground local floor = AOP:Body() -- Create a new body object floor.shape = \"Box\" -- Set the shape of the body to a box floor.size = { 100.0, 1.0, 100.0 } -- Set the size of the box (length, width, height) floor.motionType = \"Static\" -- Set the motion type of the body to static (does not move) floor.layer = \"NON_MOVING\" -- Set the layer of the body to NON_MOVING floor.activate = false -- Set the activation state of the body to false (do not activate initially) floor:Add() -- Add the body to the world Create and Configure Multiple Spheres: local sphere = AOP:Body() -- Create a new body object sphere.shape = \"Sphere\" -- Set the shape of the body to a sphere sphere.radius = 0.5 -- Set the radius of the sphere sphere.position = { -3.0, 1, 0.0 } -- Set the initial position of the sphere (x, y, z) sphere:Add() -- Add the body to the world sphere:SetLinearVelocity({ 0.0, 0.0, 5.0 }) -- Set the initial linear velocity of the sphere local sphere2 = AOP:Body() -- Create a new body object for sphere2 sphere2.shape = \"Sphere\" -- Set the shape of sphere2 to a sphere sphere2.radius = 0.5 -- Set the radius of sphere2 to 0.5 sphere2.position = { -1.0, 1, 0.0 } -- Set the initial position of sphere2 to (-1.0, 1, 0.0) sphere2:Add() -- Add sphere2 to the world sphere2:AddForce({ 0.0, 0.0, 100000.0 }) -- Apply a force of (0.0, 0.0, 100000.0) to sphere2 local sphere3 = AOP:Body() -- Create a new body object for sphere3 sphere3.shape = \"Sphere\" -- Set the shape of sphere3 to a sphere sphere3.radius = 0.5 -- Set the radius of sphere3 to 0.5 sphere3.position = { 1.0, 1, 0.0 } -- Set the initial position of sphere3 to (1.0, 1, 0.0) sphere3:Add() -- Add sphere3 to the world sphere3:AddImpulse({ 0.0, 0.0, 1500.0 }) -- Apply an impulse of (0.0, 0.0, 1500.0) to sphere3 local sphere4 = AOP:Body() -- Create a new body object for sphere4 sphere4.shape = \"Sphere\" -- Set the shape of sphere4 to a sphere sphere4.radius = 0.5 -- Set the radius of sphere4 to 0.5 sphere4.position = { 3.0, 1, 0.0 } -- Set the initial position of sphere4 to (3.0, 1, 0.0) sphere4:Add() -- Add sphere4 to the world sphere4:AddTorque({ 50000.0, 0.0, 0 }) -- Apply a torque of (50000.0, 0.0, 0) to sphere4 Run the Simulation: for i = 1, framesToSimulate do world:Update(1, deltaTime) -- Update the world with a single step world:GetState() -- Get the current state of the world end Output World States and Clean Up: -- Print the states of the world after simulation print(world:GetStates()) -- Clean up and destroy the world to free resources world:Destroy()","title":"Step-by-Step Breakdown"},{"location":"examples/basic/#notes","text":"This script initializes a world and several physical bodies with different properties and forces. It simulates the world for 1000 frames, printing the world state after each frame. The simulation environment is destroyed at the end to clean up resources. For more details on the AO Physics library and its components, please refer to the AO Physics Documentation .","title":"Notes"}]}