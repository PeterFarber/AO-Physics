{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>This documentation provides an overview of the core components of the physics simulation system: <code>World</code>, <code>Body</code>, and various <code>Constraints</code>. Each component plays a crucial role in defining the behavior and interactions of objects within the simulation.</p> <p>AO Physics is still in its early stage of development...</p>"},{"location":"#world","title":"World","text":"<p>The <code>World</code> object represents the simulation environment, managing global settings and the overall state of the simulation. It handles physical properties such as gravity, body limits, and simulation time.</p> <p>For detailed information on how to configure and use the <code>World</code>, refer to the World documentation.</p>"},{"location":"#body","title":"Body","text":"<p>The <code>Body</code> object represents an individual object within the simulation. Bodies have physical attributes like mass, position, and velocity, and they interact with other bodies through forces and constraints.</p> <p>For detailed information on the properties and methods available for <code>Body</code>, refer to the Body documentation.</p>"},{"location":"#constraints","title":"Constraints","text":"<p>Constraints define relationships and restrictions between bodies, simulating various physical joints and connections. They determine how bodies move relative to each other and the types of interactions that can occur.</p> <p>For detailed information on the different types of constraints and their configurations, refer to the Constraints documentation.</p>"},{"location":"#examples","title":"Examples","text":"<p>To help you get started with the physics simulation system, here are some examples showcasing different aspects of its usage:</p> <ol> <li>Basic: This example demonstrates how to initialize the simulation environment, create and configure bodies, apply physical motions, and update and retrieve simulation states. It covers the fundamental concepts and operations of the physics simulation system. </li> </ol> <p>More Examples Coming Soon...</p> <p>Feel free to explore these examples to gain a better understanding of how to use the physics simulation system in your projects.</p> <p>For more detailed usage and information on each component, please consult the respective documentation linked in the table of contents.</p>"},{"location":"body/","title":"Body","text":"<p>The <code>Body</code> class represents a physical object within the simulation, allowing for various configurations and interactions.</p>"},{"location":"body/#properties","title":"Properties","text":"Property Type Description Default Value <code>data</code> <code>table</code> Custom JSON data associated with the body. <code>{}</code> <code>position</code> <code>table</code> The position of the body in 3D space. <code>{ 0, 0, 0 }</code> <code>rotation</code> <code>table</code> The rotation of the body as a quaternion (x, y, z, w). <code>{ 0, 0, 0, 1 }</code> <code>linearVelocity</code> <code>table</code> The linear velocity of the <code>{ 0, 0, 0 }</code> <code>angularVelocity</code> <code>table</code> The angular velocity of the <code>{ 0, 0, 0 }</code> <code>motionType</code> <code>string</code> The motion type of the  Options are <code>\"Dynamic\"</code>, <code>\"Static\"</code>, <code>\"Kinematic\"</code>. <code>\"Dynamic\"</code> <code>motionQuality</code> <code>string</code> The motion quality of the  Options are <code>\"Discrete\"</code>, <code>\"LinearCast\"</code>. <code>\"Discrete\"</code> <code>layer</code> <code>string</code> The collision layer of the  Options are <code>\"MOVING\"</code>, <code>\"NON_MOVING\"</code>. <code>\"MOVING\"</code> <code>shape</code> <code>string</code> The shape of the  Options are <code>\"Box\"</code>, <code>\"Sphere\"</code>, <code>\"Capsule\"</code>, <code>\"Cylinder\"</code>. <code>\"Box\"</code> <code>activate</code> <code>boolean</code> Determines if the body is active. <code>true</code> <code>enhancedInternalEdgeRemoval</code> <code>boolean</code> Determines if enhanced internal edge removal is enabled. <code>false</code> <code>allowSleeping</code> <code>boolean</code> Allows the body to enter a sleeping state when not in motion. <code>true</code> <code>friction</code> <code>number</code> The friction coefficient of the <code>0.2</code> <code>restitution</code> <code>number</code> The restitution (bounciness) of the <code>0.0</code> <code>linearDamping</code> <code>number</code> The linear damping applied to the <code>0.05</code> <code>angularDamping</code> <code>number</code> The angular damping applied to the <code>0.05</code> <code>maxLinearVelocity</code> <code>number</code> The maximum linear velocity of the <code>500.0</code> <code>maxAngularVelocity</code> <code>number</code> The maximum angular velocity of the <code>0.25 * \u03c0 * 60.0</code> <code>gravityFactor</code> <code>number</code> The factor by which gravity affects the <code>1.0</code> <code>size</code> <code>table</code> The size of the body (used for <code>Box</code> shape). <code>{ 1, 1, 1 }</code> <code>radius</code> <code>number</code> The radius of the body (used for <code>Sphere</code> and <code>Capsule</code> shapes). <code>0.5</code> <code>height</code> <code>number</code> The height of the body (used for <code>Capsule</code> and <code>Cylinder</code> shapes). <code>2.0</code>"},{"location":"body/#functions","title":"Functions","text":""},{"location":"body/#add","title":"Add","text":"DetailsExample <p>Adds the body to the physics simulation and assigns it a unique <code>id</code>. </p> <p>This function serializes the body's properties and adds it to the simulation, generating and assigning a unique identifier (id) for the body. This id is used in subsequent operations to reference this specific body within the physics system.</p> <pre><code>body:Add()\n</code></pre>"},{"location":"body/#remove","title":"Remove","text":"DetailsExample <p>Removes the body from the physics simulation using its unique <code>id</code>. </p> <p>This function removes the body associated with the given <code>id</code> from the simulation. Once removed, the body's id will no longer be valid for operations within the physics system.</p> <pre><code>body:Remove()\n</code></pre>"},{"location":"body/#setdata","title":"SetData","text":"DetailsExample <p>Allows setting custom JSON data to be associated with a body within the physics simulation without affecting its actual properties. </p> <p>This function stores the provided JSON data with the body in the physics simulation but does not modify the body's physical properties or behavior. It can be used to attach metadata or other non-physical information to the body for tracking or reference purposes.</p> <pre><code>body:SetData({\"customKey\": \"customValue\"})\n</code></pre>"},{"location":"body/#getdata","title":"GetData","text":"DetailsExample <p>Retrieves the custom JSON data associated with a body within the physics simulation. </p> <p>This function returns the JSON data that was previously set using <code>SetData</code>. The retrieved data does not affect the body's physical properties or behavior and is typically used for accessing metadata or other non-physical information associated with the body.</p> <pre><code>local data = body:GetData()\n</code></pre>"},{"location":"body/#setlinearvelocity","title":"SetLinearVelocity","text":"DetailsParametersExample <p>Sets the linear velocity of the body. </p> <p>This function sets the body's linear velocity to the specified vector components, directly altering its motion in the simulation.</p> <ul> <li><code>velocity</code> (<code>table {number, number, number}</code>): A table representing the x, y, and z components of the linear velocity.</li> </ul> <pre><code>local velocity = {1.0, 2.0, 0.0}\nbody:SetLinearVelocity(velocity)\n</code></pre>"},{"location":"body/#setangularvelocity","title":"SetAngularVelocity","text":"DetailsParametersExample <p>Sets the angular velocity of the body. </p> <p>This function sets the body's angular velocity to the specified vector components, directly affecting its rotational motion in the simulation.</p> <ul> <li><code>velocity</code> (<code>table {number, number, number}</code>): A table representing the x, y, and z components of the angular velocity.</li> </ul> <pre><code>local angularVelocity = {0.1, 0.2, 0.3}\nbody:SetAngularVelocity(angularVelocity)\n</code></pre>"},{"location":"body/#addlinearvelocity","title":"AddLinearVelocity","text":"DetailsParametersExample <p>Adds to the current linear velocity of the body. </p> <p>This function modifies the body's current linear velocity by adding the specified velocity vector components to it.</p> <ul> <li><code>velocity</code> (<code>table {number, number, number}</code>): A table representing the x, y, and z components of the velocity to add.</li> </ul> <pre><code>local velocity = {1.0, 0.5, 0.0}\nbody:AddLinearVelocity(velocity)\n</code></pre>"},{"location":"body/#addangularvelocity","title":"AddAngularVelocity","text":"DetailsParametersExample <p>Adds to the current angular velocity of the body. </p> <p>This function adjusts the body's current angular velocity by adding the specified velocity vector components to it, effectively changing the body's rotational motion.</p> <ul> <li><code>velocity</code> (<code>table {number, number, number}</code>): A table representing the x, y, and z components of the angular velocity to add.</li> </ul> <pre><code>local angularVelocity = {0.1, 0.2, 0.3}\nbody:AddAngularVelocity(angularVelocity)\n</code></pre>"},{"location":"body/#addforce","title":"AddForce","text":"DetailsParametersExample <p>Applies a force to the body. </p> <p>This function applies a force to the body, influencing its movement and interaction with other bodies.</p> <ul> <li><code>force</code> (<code>table {number, number, number}</code>): A table representing the x, y, and z components of the force to apply.</li> </ul> <pre><code>local force = {10.0, 0.0, 0.0}\nbody:AddForce(force)\n</code></pre>"},{"location":"body/#addtorque","title":"AddTorque","text":"DetailsParametersExample <p>Applies a torque to the body. </p> <p>This function applies a torque to the body, affecting its rotational motion.</p> <ul> <li><code>torque</code> (<code>table {number, number, number}</code>): A table representing the x, y, and z components of the torque to apply.</li> </ul> <pre><code>local torque = {0.0, 5.0, 0.0}\nbody:AddTorque(torque)\n</code></pre>"},{"location":"body/#addimpulse","title":"AddImpulse","text":"DetailsParametersExample <p>Applies an impulse to the body. </p> <p>This function applies an impulse to the body, resulting in a sudden change in its velocity.</p> <ul> <li><code>impulse</code> (<code>table {number, number, number}</code>): A table representing the x, y, and z components of the impulse to apply.</li> </ul> <pre><code>local impulse = {0.0, 10.0, 0.0}\nbody:AddImpulse(impulse)\n</code></pre>"},{"location":"body/#castray","title":"CastRay","text":"DetailsParametersReturnsExample <p>Casts a ray from the body's current position in a specified direction to detect collisions. </p> <p>This function casts a ray from the body's current position in the specified direction and returns information about any collisions detected.</p> <ul> <li><code>direction</code> (<code>table {number, number, number}</code>): A table representing the x, y, and z components of the direction vector for the ray.</li> </ul> <ul> <li><code>result</code> (<code>table</code>): A table containing the result of the ray cast, including:</li> <li><code>hit</code> (<code>boolean</code>): Whether the ray hit something.</li> <li><code>hitPoint</code> (<code>table {number, number, number}</code>): The point of collision.</li> <li><code>hitBodyID</code> (<code>number</code>): The ID of the body that was hit.</li> </ul> <pre><code>local direction = {0.0, 0.0, -1.0}\nlocal result = body:CastRay(direction)\nif result.hit then\n    print(\"Hit at:\", result.hitPoint[1], result.hitPoint[2], result.hitPoint[3])\nend\n</code></pre>"},{"location":"body/#example","title":"Example","text":"<p>This example demonstrates how to create a sphere body, configure its properties, and set its linear velocity.</p>"},{"location":"body/#code","title":"Code","text":"<pre><code>local sphere = AOP:Body()               -- Create a new body instance.\nsphere.shape = \"Sphere\"                -- Set the shape of the body to \"Sphere\".\nsphere.radius = 0.5                    -- Set the radius of the sphere to 0.5 units.\nsphere.position = { -3.0, 1, 0.0 }    -- Position the sphere at coordinates (-3.0, 1, 0.0).\nsphere.layer = \"MOVING\"                -- Assign the body to the \"MOVING\" layer.\nsphere.activate = true                 -- Activate the body in the simulation.\nsphere:Add()                           -- Add the body to the physics simulation.\nsphere:SetLinearVelocity({ 0.0, 0.0, 5.0 })  -- Set the linear velocity of the body to (0.0, 0.0, 5.0).\n</code></pre>"},{"location":"body/#description","title":"Description","text":"<ul> <li>Create a Body Instance: <code>AOP:Body()</code> creates a new body instance.</li> <li>Set Shape: The <code>shape</code> property is set to <code>\"Sphere\"</code>, defining the body's shape.</li> <li>Set Radius: The <code>radius</code> property is set to <code>0.5</code>, defining the sphere's size.</li> <li>Set Position: The <code>position</code> property sets the sphere's location in 3D space.</li> <li>Set Layer: The <code>layer</code> property is set to <code>\"MOVING\"</code>, indicating the body is part of the moving layer.</li> <li>Activate the Body: The <code>activate</code> property is set to <code>true</code> to enable the body in the simulation.</li> <li>Add to Simulation: The <code>Add</code> method is called to add the body to the physics simulation.</li> <li>Set Linear Velocity: The <code>SetLinearVelocity</code> method is used to set the body's linear velocity to <code>(0.0, 0.0, 5.0)</code>, influencing its movement in the simulation.</li> </ul>"},{"location":"character/","title":"Character","text":"<p>The <code>Character</code> class represents a player or entity character within the simulation, providing various configurations and methods for interaction.</p>"},{"location":"character/#properties","title":"Properties","text":"Property Type Description Default Value <code>position</code> <code>table</code> The position of the character in 3D space. <code>{ 0, 0, 0 }</code> <code>rotation</code> <code>table</code> The rotation of the character as a quaternion (x, y, z, w). <code>{ 0, 0, 0, 1 }</code> <code>radiusStanding</code> <code>number</code> The radius of the character when standing. <code>0.5</code> <code>heightStanding</code> <code>number</code> The height of the character when standing. <code>2.0</code> <code>radiusCrouching</code> <code>number</code> The radius of the character when crouching. <code>0.5</code> <code>heightCrouching</code> <code>number</code> The height of the character when crouching. <code>1.0</code> <code>up</code> <code>table</code> The up direction for the character, represented as a vector. <code>{ 0, 1, 0 }</code> <code>friction</code> <code>number</code> The friction coefficient of the character. <code>0.5</code> <code>gravityFactor</code> <code>number</code> The factor by which gravity affects the character. <code>1.0</code> <code>jumpForce</code> <code>number</code> The force applied when the character jumps. <code>6.0</code> <code>maxSlopeAngle</code> <code>number</code> The maximum slope angle the character can walk on. <code>45.0</code> <code>speed</code> <code>number</code> The movement speed of the character. <code>1.0</code> <code>sprintMultiplier</code> <code>number</code> The multiplier applied to the character's speed when sprinting. <code>2.0</code> <code>canMoveWhileJumping</code> <code>boolean</code> Determines if the character can move while jumping. <code>false</code> <code>activate</code> <code>boolean</code> Determines if the character is active. <code>true</code> <code>layer</code> <code>string</code> The collision layer of the character. Options are <code>\"MOVING\"</code>, <code>\"NON_MOVING\"</code>. <code>\"MOVING\"</code>"},{"location":"character/#functions","title":"Functions","text":""},{"location":"character/#add","title":"Add","text":"DetailsExample <p>Adds the character to the simulation and assigns it a unique <code>id</code>. </p> <p>This function serializes the character's properties and adds it to the simulation, generating and assigning a unique identifier (id) for the character. This id is used in subsequent operations to reference this specific character within the simulation.</p> <pre><code>local character = AOP:Character()\ncharacter:Add()\n</code></pre>"},{"location":"character/#input","title":"Input","text":"DetailsReturnsExample <p>Creates an input table for controlling the character's movement. </p> <p>This function returns a table with default values for character movement, including directions and action states (jump, sprint, crouch). This input table can be modified and passed to <code>SendInput</code> to control the character.</p> <ul> <li><code>input</code> (<code>table</code>): A table containing the following fields:<ul> <li><code>x</code> (<code>number</code>): The input value for movement along the x-axis (left/right).</li> <li><code>z</code> (<code>number</code>): The input value for movement along the z-axis (forward/backward).</li> <li><code>jump</code> (<code>boolean</code>): Whether the character should jump.</li> <li><code>sprint</code> (<code>boolean</code>): Whether the character should sprint.</li> <li><code>crouch</code> (<code>boolean</code>): Whether the character should crouch.</li> </ul> </li> </ul> <pre><code>local character = AOP:Character()\nlocal input = character:Input()\ninput.x = 1.0\ninput.z = 0.5\ninput.jump = true\n</code></pre>"},{"location":"character/#sendinput","title":"SendInput","text":"DetailsParametersExample <p>Sends the character's movement input to the simulation. </p> <p>This function takes an input table (as created by the <code>Input</code> function) and sends it to the simulation, updating the character's movement and actions based on the input.</p> <ul> <li><code>data</code> (<code>table</code>): A table containing the character's movement and action input values.</li> </ul> <pre><code>local character = AOP:Character()\ncharacter:Add()\nlocal input = character:Input()\ninput.x = 1.0\ninput.z = 0.5\ninput.jump = true\ncharacter:SendInput(input)\n</code></pre>"},{"location":"character/#example","title":"Example","text":"<p>This example demonstrates how to create a character, configure its properties, and control its movement.</p>"},{"location":"character/#code","title":"Code","text":"<pre><code>local character = AOP:Character()     -- Create a new character instance.\ncharacter.position = { 0, 1, 0 }      -- Set the initial position of the character.\ncharacter.speed = 2.0                 -- Set the movement speed of the character.\ncharacter:Add()                       -- Add the character to the simulation.\n\nlocal input = character:Input()       -- Create an input table.\ninput.x = 1.0                         -- Move right.\ninput.z = 0.5                         -- Move forward.\ninput.jump = true                     -- Make the character jump.\n\ncharacter:SendInput(input)            -- Send the input to the simulation.\n</code></pre>"},{"location":"character/#description","title":"Description","text":"<ul> <li>Create a Character Instance: <code>AOP:Character()</code> creates a new character instance.</li> <li>Set Position: The <code>position</code> property is set to <code>{ 0, 1, 0 }</code>, defining the character's initial location in the simulation.</li> <li>Set Speed: The <code>speed</code> property is set to <code>2.0</code>, increasing the character's movement speed.</li> <li>Add to Simulation: The <code>Add</code> method is called to add the character to the simulation.</li> <li>Create Input: The <code>Input</code> method is used to generate an input table for controlling the character.</li> <li>Modify Input: The <code>x</code>, <code>z</code>, and <code>jump</code> fields in the input table are set to control the character's movement and jumping action.</li> <li>Send Input: The <code>SendInput</code> method sends the input to the simulation, causing the character to move and jump.</li> </ul>"},{"location":"constraint/","title":"Constraints","text":"<p>The <code>Constraints</code> class defines various constraints used to govern the relationships between bodies in the simulation. Each constraint type has specific properties and methods to manage and apply the constraints.</p>"},{"location":"constraint/#constraint-types","title":"Constraint Types","text":""},{"location":"constraint/#hinge-constraint","title":"Hinge Constraint","text":"<p>Represents a hinge-like connection between two bodies.</p>"},{"location":"constraint/#properties","title":"Properties","text":"Property Type Description Default Value <code>type</code> <code>string</code> Type of constraint. <code>\"Hinge\"</code> <code>space</code> <code>string</code> Space in which the constraint is defined. <code>\"WorldSpace\"</code> <code>point1</code> <code>table</code> The hinge's attachment point on the first body. <code>{ 0, 0, 0 }</code> <code>hingeAxis1</code> <code>table</code> The axis of rotation for the first body. <code>{ 0, 1, 0 }</code> <code>normalAxis1</code> <code>table</code> The normal axis for the first body. <code>{ 1, 0, 0 }</code> <code>point2</code> <code>table</code> The hinge's attachment point on the second body. <code>{ 0, 0, 0 }</code> <code>hingeAxis2</code> <code>table</code> The axis of rotation for the second body. <code>{ 0, 1, 0 }</code> <code>normalAxis2</code> <code>table</code> The normal axis for the second body. <code>{ 1, 0, 0 }</code> <code>limitsMin</code> <code>number</code> Minimum angle limit for the hinge. <code>-180.0</code> <code>limitsMax</code> <code>number</code> Maximum angle limit for the hinge. <code>180.0</code> <code>maxFrictionTorque</code> <code>number</code> Maximum friction torque for the hinge. <code>0.0</code> <code>limitsSpringSettings</code> <code>table</code> Spring settings for the angle limits. <code>{ mode = \"FrequencyAndDamping\", frequency = 0.0, stiffness = 0.0, damping = 0.0 }</code> <code>motorSettings</code> <code>table</code> Motor settings for the hinge. <code>{ frequency = 0.0, damping = 0.0 }</code> <code>motorState</code> <code>string</code> State of the motor. <code>\"Off\"</code> <code>targetAngularVelocity</code> <code>number</code> Target angular velocity of the hinge. <code>0.0</code> <code>targetAngle</code> <code>number</code> Target angle of the hinge. <code>0.0</code>"},{"location":"constraint/#slider-constraint","title":"Slider Constraint","text":"<p>Represents a slider-like connection that allows movement along a single axis.</p>"},{"location":"constraint/#properties_1","title":"Properties","text":"Property Type Description Default Value <code>type</code> <code>string</code> Type of constraint. <code>\"Slider\"</code> <code>space</code> <code>string</code> Space in which the constraint is defined. <code>\"WorldSpace\"</code> <code>autoDetectPoint</code> <code>boolean</code> Whether the attachment point is auto-detected. <code>false</code> <code>point1</code> <code>table</code> The slider's attachment point on the first body. <code>{ 0, 0, 0 }</code> <code>sliderAxis1</code> <code>table</code> The axis along which the slider moves for the first body. <code>{ 1, 0, 0 }</code> <code>normalAxis1</code> <code>table</code> The normal axis for the first body. <code>{ 0, 1, 0 }</code> <code>point2</code> <code>table</code> The slider's attachment point on the second body. <code>{ 0, 0, 0 }</code> <code>sliderAxis2</code> <code>table</code> The axis along which the slider moves for the second body. <code>{ 1, 0, 0 }</code> <code>normalAxis2</code> <code>table</code> The normal axis for the second body. <code>{ 0, 1, 0 }</code> <code>limitsMin</code> <code>number</code> Minimum movement limit for the slider. <code>-3.40282347e+38</code> <code>limitsMax</code> <code>number</code> Maximum movement limit for the slider. <code>3.40282347e+38</code> <code>maxFrictionForce</code> <code>number</code> Maximum friction force for the slider. <code>0.0</code> <code>limitsSpringSettings</code> <code>table</code> Spring settings for the movement limits. <code>{ mode = \"FrequencyAndDamping\", frequency = 0.0, stiffness = 0.0, damping = 0.0 }</code> <code>motorSettings</code> <code>table</code> Motor settings for the slider. <code>{ frequency = 0.0, damping = 0.0 }</code>"},{"location":"constraint/#pulley-constraint","title":"Pulley Constraint","text":"<p>Represents a pulley system connecting two bodies.</p>"},{"location":"constraint/#properties_2","title":"Properties","text":"Property Type Description Default Value <code>type</code> <code>string</code> Type of constraint. <code>\"Pulley\"</code> <code>space</code> <code>string</code> Space in which the constraint is defined. <code>\"WorldSpace\"</code> <code>bodyPoint1</code> <code>table</code> Attachment point on the first body. <code>{ 0, 0, 0 }</code> <code>fixedPoint1</code> <code>table</code> Fixed point in the world for the first pulley. <code>{ 0, 0, 0 }</code> <code>bodyPoint2</code> <code>table</code> Attachment point on the second body. <code>{ 0, 0, 0 }</code> <code>fixedPoint2</code> <code>table</code> Fixed point in the world for the second pulley. <code>{ 0, 0, 0 }</code> <code>ratio</code> <code>number</code> Ratio of the pulley system. <code>1.0</code> <code>minLength</code> <code>number</code> Minimum length of the pulley. <code>0.0</code> <code>maxLength</code> <code>number</code> Maximum length of the pulley. <code>0.0</code>"},{"location":"constraint/#point-constraint","title":"Point Constraint","text":"<p>Represents a point-to-point connection between two bodies.</p>"},{"location":"constraint/#properties_3","title":"Properties","text":"Property Type Description Default Value <code>type</code> <code>string</code> Type of constraint. <code>\"Point\"</code> <code>space</code> <code>string</code> Space in which the constraint is defined. <code>\"WorldSpace\"</code> <code>point1</code> <code>table</code> The point of attachment on the first body. <code>{ 0, 0, 0 }</code> <code>point2</code> <code>table</code> The point of attachment on the second body. <code>{ 0, 0, 0 }</code>"},{"location":"constraint/#gear-constraint","title":"Gear Constraint","text":"<p>Represents a gear-like connection between two bodies.</p>"},{"location":"constraint/#properties_4","title":"Properties","text":"Property Type Description Default Value <code>type</code> <code>string</code> Type of constraint. <code>\"Gear\"</code> <code>space</code> <code>string</code> Space in which the constraint is defined. <code>\"WorldSpace\"</code> <code>numTeeth1</code> <code>number</code> Number of teeth on the first gear. <code>1</code> <code>numTeeth2</code> <code>number</code> Number of teeth on the second gear. <code>1</code> <code>hingeAxis1</code> <code>table</code> The axis of rotation for the first gear. <code>{ 1, 0, 0 }</code> <code>hingeAxis2</code> <code>table</code> The axis of <p>rotation for the second gear.          | <code>{ 1, 0, 0 }</code>         | | <code>ratio</code>                     | <code>number</code> | Gear ratio between the two gears.                  | <code>1.0</code>                 |</p>"},{"location":"constraint/#fixed-constraint","title":"Fixed Constraint","text":"<p>Represents a fixed connection between two bodies.</p>"},{"location":"constraint/#properties_5","title":"Properties","text":"Property Type Description Default Value <code>type</code> <code>string</code> Type of constraint. <code>\"Fixed\"</code> <code>space</code> <code>string</code> Space in which the constraint is defined. <code>\"WorldSpace\"</code> <code>point1</code> <code>table</code> The attachment point on the first body. <code>{ 0, 0, 0 }</code> <code>axisX1</code> <code>table</code> The X axis direction for the first body. <code>{ 0, 1, 0 }</code> <code>axisY1</code> <code>table</code> The Y axis direction for the first body. <code>{ 1, 0, 0 }</code> <code>point2</code> <code>table</code> The attachment point on the second body. <code>{ 0, 0, 0 }</code> <code>axisX2</code> <code>table</code> The X axis direction for the second body. <code>{ 0, 1, 0 }</code> <code>axisY2</code> <code>table</code> The Y axis direction for the second body. <code>{ 1, 0, 0 }</code>"},{"location":"constraint/#distance-constraint","title":"Distance Constraint","text":"<p>Represents a distance constraint between two bodies.</p>"},{"location":"constraint/#properties_6","title":"Properties","text":"Property Type Description Default Value <code>type</code> <code>string</code> Type of constraint. <code>\"Distance\"</code> <code>space</code> <code>string</code> Space in which the constraint is defined. <code>\"WorldSpace\"</code> <code>point1</code> <code>table</code> The attachment point on the first body. <code>{ 0, 0, 0 }</code> <code>point2</code> <code>table</code> The attachment point on the second body. <code>{ 0, 0, 0 }</code> <code>minDistance</code> <code>number</code> Minimum distance between the bodies. <code>-1.0</code> <code>maxDistance</code> <code>number</code> Maximum distance between the bodies. <code>-1.0</code> <code>limitsSpringSettings</code> <code>table</code> Spring settings for distance limits. <code>{ mode = \"FrequencyAndDamping\", frequency = 0.0, stiffness = 0.0, damping = 0.0 }</code>"},{"location":"constraint/#cone-constraint","title":"Cone Constraint","text":"<p>Represents a cone-like connection allowing rotation within a cone.</p>"},{"location":"constraint/#properties_7","title":"Properties","text":"Property Type Description Default Value <code>type</code> <code>string</code> Type of constraint. <code>\"Cone\"</code> <code>space</code> <code>string</code> Space in which the constraint is defined. <code>\"WorldSpace\"</code> <code>point1</code> <code>table</code> The point of attachment on the first body. <code>{ 0, 0, 0 }</code> <code>twistAxis1</code> <code>table</code> The twist axis for the first body. <code>{ 0, 1, 0 }</code> <code>point2</code> <code>table</code> The point of attachment on the second body. <code>{ 0, 0, 0 }</code> <code>twistAxis2</code> <code>table</code> The twist axis for the second body. <code>{ 0, 1, 0 }</code> <code>halfConeAngle</code> <code>number</code> Half of the cone angle defining the constraint. <code>0.0</code>"},{"location":"constraint/#functions","title":"Functions","text":""},{"location":"constraint/#add","title":"Add","text":"DetailsParametersReturnsExample <p>Adds the constraint between two bodies. This method creates and adds the constraint between the two specified bodies, returning the unique ID of the created constraint.</p> <ul> <li><code>body1</code> (<code>object</code>): The first body to connect.</li> <li><code>body2</code> (<code>object</code>): The second body to connect.</li> </ul> <ul> <li><code>id</code> (<code>number</code>): The unique identifier for the created constraint.</li> </ul> <pre><code>local id = AOP:Add(body1, body2)\n</code></pre>"},{"location":"constraint/#remove","title":"Remove","text":"DetailsExample <p>Removes the specified constraint from the physics simulation.</p> <pre><code>AOP:Remove(id)\n</code></pre>"},{"location":"lua_module/","title":"Lua Module","text":"<p>Note</p> <p>The Lua module in this documentation provides a convenient interface for interacting with the AO Physics library, which is implemented in C++. The module allows users to create and manipulate physics bodies, apply forces and constraints, and simulate physics interactions.</p> <p>To use the Lua module, you need to require the \"aop\" module, which internally loads the C++ AO Physics library. Additionally, you will need to import other Lua modules such as \"json\" and \"class\" for JSON encoding and class creation, respectively.</p> <p>Overall, the Lua module provides a high-level interface for working with the AO Physics library, making it easier to integrate physics simulations into Lua-based applications.</p> AOP.lua <pre><code>_AOP = require(\"aop\")\nlocal json = require('json')\nlocal class = require('class')\n\nAOPModule = class(function(aop) end)\n\nAOP = AOPModule()\n\nfunction AOP:Body()\n  local body = {}\n  body.id = -1\n  body.data = {} -- Used to store custom data\n  body.position = { 0, 0, 0 }\n  body.rotation = { 0, 0, 0, 1 }\n  body.linearVelocity = { 0, 0, 0 }\n  body.angularVelocity = { 0, 0, 0 }\n  body.motionType = \"Dynamic\"     -- \"Dynamic\" | \"Static\" | \"Kinematic\"\n  body.motionQuality = \"Discrete\" -- \"Discrete\" | \"LinearCast\"\n  body.layer = \"MOVING\"           -- \"MOVING\" | \"NON_MOVING\"\n  body.shape = \"Box\"              -- \"Box\" | \"Sphere\" | \"Capsule\" | \"Cylinder\"\n  body.activate = true\n  body.enhancedInternalEdgeRemoval = false\n  body.allowSleeping = true\n  body.friction = 0.2\n  body.restitution = 0.0\n  body.linearDamping = 0.05\n  body.angularDamping = 0.05\n  body.maxLinearVelocity = 500.0\n  body.maxAngularVelocity = 0.25 * 3.14159265359 * 60.0\n  body.gravityFactor = 1.0\n  body.size = { 1, 1, 1 }\n  body.radius = 0.5\n  body.height = 2.0\n\n  function body:Add()\n    self.data = json.encode(self.data);\n    self.id = math.floor(_AOP.add_body(json.encode(self)))\n    self.data = json.decode(self.data);\n  end\n\n  function body:SetData(data)\n    _AOP.set_data_body(self.id, json.encode(data))\n  end\n\n  function body:GetData()\n    return json.decode(_AOP.get_data_body(self.id))\n  end\n\n  function body:SetLinearVelocity(velocity --[[{x, y, z}]])\n    _AOP.set_linear_velocity(self.id, velocity[1], velocity[2], velocity[3])\n  end\n\n  function body:SetAngularVelocity(velocity --[[{x, y, z}]])\n    _AOP.set_angular_velocity(self.id, velocity[1], velocity[2], velocity[3])\n  end\n\n  function body:AddLinearVelocity(velocity --[[{x, y, z}]])\n    _AOP.add_linear_velocity(self.id, velocity[1], velocity[2], velocity[3])\n  end\n\n  function body:AddAngularVelocity(velocity --[[{x, y, z}]])\n    _AOP.add_angular_velocity(self.id, velocity[1], velocity[2], velocity[3])\n  end\n\n  function body:AddForce(force --[[{x, y, z}]])\n    _AOP.add_force(self.id, force[1], force[2], force[3])\n  end\n\n  function body:AddTorque(torque --[[{x, y, z}]])\n    _AOP.add_torque(self.id, torque[1], torque[2], torque[3])\n  end\n\n  function body:AddImpulse(impulse --[[{x, y, z}]])\n    _AOP.add_impulse(self.id, impulse[1], impulse[2], impulse[3])\n  end\n\n  function body:CastRay(direction --[[{x, y, z}]])\n    local hit = json.decode(_AOP.cast_ray(self.id, direction[1], direction[2], direction[3]))\n    local result = {\n      hit = hit.hit,\n      hitPoint = hit.hitPoint,\n      hitBodyID = hit.hitBodyID\n    }\n    return result\n  end\n\n  function body:Remove()\n    _AOP.remove_body(self.id)\n  end\n\n  return body;\nend\n\nfunction AOP:ConstraintHinge()\n  local hingeConstraint = {};\n  hingeConstraint.type = \"Hinge\"\n  hingeConstraint.space = \"WorldSpace\"      -- \"WorldSpace\" | \"LocalToBodyCOM\"\n  hingeConstraint.point1 = { 0, 0, 0 }      -- [float] x, y, z\n  hingeConstraint.hingeAxis1 = { 0, 1, 0 }  -- [float] x, y, z\n  hingeConstraint.normalAxis1 = { 1, 0, 0 } -- [float] x, y, z\n  hingeConstraint.point2 = { 0, 0, 0 }      -- [float] x, y, z\n  hingeConstraint.hingeAxis2 = { 0, 1, 0 }  -- [float] x, y, z\n  hingeConstraint.normalAxis2 = { 1, 0, 0 } -- [float] x, y, z\n  hingeConstraint.limitsMin = -180.0        -- [Degrees]\n  hingeConstraint.limitsMax = 180           -- [float] Degrees\n  hingeConstraint.maxFrictionTorque = 0.0\n  hingeConstraint.limitsSpringSettings = {\n    mode = \"FrequencyAndDamping\", -- [string] \"FrequencyAndDamping\" | \"StiffnessAndDamping\"\n    frequency = 0.0,\n    stiffness = 0.0,\n    damping = 0.0\n  }\n  hingeConstraint.motorSettings = {\n    frequency = 0.0,\n    damping = 0.0\n  }\n  hingeConstraint.motorState = \"Off\" -- \"Off\" | \"Velocity\" | \"Position\"\n  hingeConstraint.targetAngularVelocity = 0.0\n  hingeConstraint.targetAngle = 0.0\n\n  function hingeConstraint:Add(body1, body2)\n    self.body1ID = body1.id\n    self.body2ID = body2.id\n    self.id = _AOP.add_constraint(json.encode(self))\n    return self.id\n  end\n\n  function hingeConstraint:Remove()\n    _AOP.remove_constraint(self.id)\n  end\n\n  return hingeConstraint;\nend\n\nfunction AOP:ConstraintSlider()\n  local sliderConstraint = {};\n  sliderConstraint.type = \"Slider\"\n  sliderConstraint.space = \"WorldSpace\"      -- \"WorldSpace\" | \"LocalToBodyCOM\"\n  sliderConstraint.autoDetectPoint = false\n  sliderConstraint.point1 = { 0, 0, 0 }      -- [float] x, y, z\n  sliderConstraint.sliderAxis1 = { 1, 0, 0 } -- [float] x, y, z\n  sliderConstraint.normalAxis1 = { 0, 1, 0 } -- [float] x, y, z\n  sliderConstraint.point2 = { 0, 0, 0 }      -- [float] x, y, z\n  sliderConstraint.sliderAxis2 = { 1, 0, 0 } -- [float] x, y, z\n  sliderConstraint.normalAxis2 = { 0, 1, 0 } -- [float] x, y, z\n  sliderConstraint.limitsMin = -3.40282347e+38\n  sliderConstraint.limitsMax = 3.40282347e+38\n  sliderConstraint.maxFrictionForce = 0.0\n  sliderConstraint.limitsSpringSettings = {\n    mode = \"FrequencyAndDamping\", -- [string] \"FrequencyAndDamping\" | \"StiffnessAndDamping\"\n    frequency = 0.0,\n    stiffness = 0.0,\n    damping = 0.0\n  }\n  sliderConstraint.motorSettings = {\n    frequency = 0.0,\n    damping = 0.0\n  }\n\n  function sliderConstraint:Add(body1, body2)\n    self.body1ID = body1.id\n    self.body2ID = body2.id\n    self.id = _AOP.add_constraint(json.encode(self))\n    return self.id\n  end\n\n  function sliderConstraint:Remove()\n    _AOP.remove_constraint(self.id)\n  end\n\n  return sliderConstraint;\nend\n\nfunction AOP:ConstraintPulley()\n  local pulleyConstraint = {};\n  pulleyConstraint.type = \"Pulley\"\n  pulleyConstraint.space = \"WorldSpace\"      -- \"WorldSpace\" | \"LocalToBodyCOM\"\n  pulleyConstraint.bodyPoint1 = { 0, 0, 0 }  -- [float] x, y, z\n  pulleyConstraint.fixedPoint1 = { 0, 0, 0 } -- [float] x, y, z\n  pulleyConstraint.bodyPoint2 = { 0, 0, 0 }  -- [float] x, y, z\n  pulleyConstraint.fixedPoint2 = { 0, 0, 0 } -- [float] x, y, z\n  pulleyConstraint.ratio = 1.0\n  pulleyConstraint.minLength = 0.0\n  pulleyConstraint.maxLength = 0.0\n\n  function pulleyConstraint:Add(body1, body2)\n    self.body1ID = body1.id\n    self.body2ID = body2.id\n    self.id = _AOP.add_constraint(json.encode(self))\n    return self.id\n  end\n\n  function pulleyConstraint:Remove()\n    _AOP.remove_constraint(self.id)\n  end\n\n  return pulleyConstraint;\nend\n\nfunction AOP:ConstraintPoint()\n  local pointConstraint = {};\n  pointConstraint.type = \"Point\"\n  pointConstraint.space = \"WorldSpace\" -- \"WorldSpace\" | \"LocalToBodyCOM\"\n  pointConstraint.point1 = { 0, 0, 0 } -- [float] x, y, z\n  pointConstraint.point2 = { 0, 0, 0 } -- [float] x, y, z\n\n  function pointConstraint:Add(body1, body2)\n    self.body1ID = body1.id\n    self.body2ID = body2.id\n    self.id = _AOP.add_constraint(json.encode(self))\n    return self.id\n  end\n\n  function pointConstraint:Remove()\n    _AOP.remove_constraint(self.id)\n  end\n\n  return pointConstraint;\nend\n\nfunction AOP:ConstraintGear()\n  local gearConstraint = {};\n  gearConstraint.type = \"Gear\"\n  gearConstraint.space = \"WorldSpace\" -- \"WorldSpace\" | \"LocalToBodyCOM\"\n  gearConstraint.numTeeth1 = 1\n  gearConstraint.numTeeth2 = 1\n  gearConstraint.hingeAxis1 = { 1, 0, 0 } -- [float] x, y, z\n  gearConstraint.hingeAxis2 = { 1, 0, 0 } -- [float] x, y, z\n  gearConstraint.ratio = 1.0\n\n  function gearConstraint:Add(body1, body2)\n    self.body1ID = body1.id\n    self.body2ID = body2.id\n    self.id = _AOP.add_constraint(json.encode(self))\n    return self.id\n  end\n\n  function gearConstraint:Remove()\n    _AOP.remove_constraint(self.id)\n  end\n\n  return gearConstraint;\nend\n\nfunction AOP:ConstraintFixed()\n  local fixedConstraint = {};\n  fixedConstraint.type = \"Fixed\"\n  fixedConstraint.space = \"WorldSpace\" -- \"WorldSpace\" | \"LocalToBodyCOM\"\n  fixedConstraint.point1 = { 0, 0, 0 } -- [float] x, y, z\n  fixedConstraint.axisX1 = { 0, 1, 0 } -- [float] x, y, z\n  fixedConstraint.axisY1 = { 1, 0, 0 } -- [float] x, y, z\n  fixedConstraint.point2 = { 0, 0, 0 } -- [float] x, y, z\n  fixedConstraint.axisX2 = { 0, 1, 0 } -- [float] x, y, z\n  fixedConstraint.axisY2 = { 1, 0, 0 } -- [float] x, y, z\n\n  function fixedConstraint:Add(body1, body2)\n    self.body1ID = body1.id\n    self.body2ID = body2.id\n    self.id = _AOP.add_constraint(json.encode(self))\n    return self.id\n  end\n\n  function fixedConstraint:Remove()\n    _AOP.remove_constraint(self.id)\n  end\n\n  return fixedConstraint;\nend\n\nfunction AOP:ConstraintDistance()\n  local distanceConstraint = {};\n  distanceConstraint.type = \"Distance\"\n  distanceConstraint.space = \"WorldSpace\" -- \"WorldSpace\" | \"LocalToBodyCOM\"\n  distanceConstraint.point1 = { 0, 0, 0 } -- [float] x, y, z\n  distanceConstraint.point2 = { 0, 0, 0 } -- [float] x, y, z\n  distanceConstraint.minDistance = -1.0\n  distanceConstraint.maxDistance = -1.0\n  distanceConstraint.limitsSpringSettings = {\n    mode = \"FrequencyAndDamping\", -- [string] \"FrequencyAndDamping\" | \"StiffnessAndDamping\"\n    frequency = 0.0,\n    stiffness = 0.0,\n    damping = 0.0\n  }\n\n  function distanceConstraint:Add(body1, body2)\n    self.body1ID = body1.id\n    self.body2ID = body2.id\n    self.id = _AOP.add_constraint(json.encode(self))\n    return self.id\n  end\n\n  function distanceConstraint:Remove()\n    _AOP.remove_constraint(self.id)\n  end\n\n  return distanceConstraint;\nend\n\nfunction AOP:ConstraintCone()\n  local coneConstraint = {};\n  coneConstraint.type = \"Cone\"\n  coneConstraint.space = \"WorldSpace\"     -- \"WorldSpace\" | \"LocalToBodyCOM\"\n  coneConstraint.point1 = { 0, 0, 0 }     -- [float] x, y, z\n  coneConstraint.twistAxis1 = { 0, 1, 0 } -- [float] x, y, z\n  coneConstraint.point2 = { 0, 0, 0 }     -- [float] x, y, z\n  coneConstraint.twistAxis2 = { 0, 1, 0 } -- [float] x, y, z\n  coneConstraint.halfConeAngle = 0.0\n\n  function coneConstraint:Add(body1, body2)\n    self.body1ID = body1.id\n    self.body2ID = body2.id\n    self.id = _AOP.add_constraint(json.encode(self))\n    return self.id\n  end\n\n  function coneConstraint:Remove()\n    _AOP.remove_constraint(self.id)\n  end\n\n  return coneConstraint;\nend\n\nfunction AOP:Character()\n  local character = {\n    canMoveWhileJumping = false,\n    speed = 1.0,\n    sprintSpeed = 2.0,\n    jumpForce = 6.0,\n    heightStanding = 1.35,\n    radiusStanding = 0.3,\n    maxSlopeAngle = 45.0,\n    friction = 0.5,\n    mass = 0.0,\n    gravityFactor = 1.0,\n    position = { 0, 0, 0 },\n    rotation = { 0, 0, 0, 1 },\n    up = { 0, 1, 0 },\n    layer = \"MOVING\", -- \"MOVING\" | \"NON_MOVING\"\n    activate = true\n  }\n  character.id = -1;\n  function character:Add()\n    self.id = math.floor(_AOP.add_character(json.encode(self)))\n    return self.id;\n  end\n\n  function character:Input()\n    local input = {\n      x = 0,\n      z = 0,\n      jump = false,\n      sprint = false,\n      crouch = false\n    }\n    return input\n  end\n\n  function character:SendInput(data)\n    local msg = {\n      id = self.id,\n      input = { data.x, data.z },\n      jump = data.jump,\n      sprint = data.sprint,\n      crouch = data.crouch\n    }\n    _AOP.move_character(json.encode(msg))\n  end\n\n  return character;\nend\n\nfunction AOP:World()\n  local world = {\n    gravity = { 0.0, -9.81, 0.0 },\n    timeBeforeSleep = 0.5,\n    allowSleeping = true,\n    maxBodies = 1024,\n    numBodyMutexes = 0,\n    maxBodyPairs = 1024,\n    maxContactConstraints = 1024\n  }\n  world.WorldStates = {}\n\n  function world:Create()\n    _AOP.world_create(json.encode(self))\n  end\n\n  function world:Update(steps, deltaTime)\n    _AOP.world_update(steps, deltaTime)\n  end\n\n  function world:GetState()\n    local worldState = _AOP.get_world_state()\n    table.insert(self.WorldStates, worldState)\n    return worldState\n  end\n\n  function world:GetStates()\n    local state = [[{ \"worldStates\": []]\n    for i = 1, #self.WorldStates do\n      state = state .. self.WorldStates[i] .. \",\"\n    end\n    state = state:sub(1, #state - 1)\n    state = state .. \"]}\"\n    self.WorldStates = {}\n    return state\n  end\n\n  function world:Destroy()\n    _AOP.world_destroy()\n  end\n\n  return world;\nend\n\nreturn AOP\n</code></pre> class.lua <pre><code>function class(base, init)\n  local c = {} -- a new class instance\n  if not init and type(base) == 'function' then\n    init = base\n    base = nil\n  elseif type(base) == 'table' then\n    -- our new class is a shallow copy of the base class!\n    for i, v in pairs(base) do\n      c[i] = v\n    end\n    c._base = base\n  end\n  -- the class will be the metatable for all its objects,\n  -- and they will look up their methods in it.\n  c.__index = c\n\n  -- expose a constructor which can be called by &lt;classname&gt;(&lt;args&gt;)\n  local mt = {}\n  mt.__call = function(class_tbl, ...)\n    local obj = {}\n    setmetatable(obj, c)\n    if init then\n      init(obj, ...)\n    else\n      -- make sure that any stuff from the base class is initialized!\n      if base and base.init then\n        base.init(obj, ...)\n      end\n    end\n    return obj\n  end\n  c.init = init\n  c.is_a = function(self, klass)\n    local m = getmetatable(self)\n    while m do\n      if m == klass then return true end\n      m = m._base\n    end\n    return false\n  end\n  setmetatable(c, mt)\n  return c\nend\n</code></pre>"},{"location":"setup/","title":"Setup","text":"<p>This guide will walk you through the process of setting up and creating your own physics simulation using the AO-Physics library. By following these steps, you'll be able to integrate AO-Physics into your Lua projects with ease.</p>"},{"location":"setup/#step-1-clone-the-ao-physics-repository","title":"Step 1: Clone the AO-Physics Repository","text":"<p>Start by cloning the official AO-Physics GitHub repository. This repository contains all the necessary files and resources to get you started.</p> <p>Open your terminal and run the following command:</p> <pre><code>git clone https://github.com/PeterFarber/AO-Physics.git\n</code></pre> <p>Info</p> <p>This command will download the entire AO-Physics project to your local machine. The repository includes the core library, examples, and other important assets.</p>"},{"location":"setup/#step-2-copy-the-build-directory-contents","title":"Step 2: Copy the Build Directory Contents","text":"<p>After cloning the repository, you'll need to integrate the AO-Physics library into your project. To do this, copy the contents of the <code>build</code> directory from the cloned repository to your module's source code directory.</p> <p>Navigate to the cloned directory:</p> <pre><code>cd AO-Physics\n</code></pre> <p>Then, copy the contents:</p> <pre><code>cp -r build/* /path/to/your/module/source\n</code></pre> <p>Info</p> <p>Replace <code>/path/to/your/module/source</code> with the actual path to your module\u2019s source code. The <code>build</code> directory contains precompiled assets and scripts that are essential for running the AO-Physics library.</p>"},{"location":"setup/#step-3-include-aoplua-in-your-process","title":"Step 3: Include AOP.lua in Your Process","text":"<p>To utilize AO-Physics in your Lua project, you need to include the <code>AOP.lua</code> script in your <code>process.lua</code> file. This script provides the necessary functions and classes to build physics simulations.</p> <p>Add the following line to the top of your <code>process.lua</code> file:</p> <pre><code>local AOP = require('AOP')\n</code></pre> <p>Info</p> <p>This line imports the AO-Physics library, making its features available in your script. Now, you can call AO-Physics functions and access its physics engine.</p>"},{"location":"setup/#step-4-write-your-lua-physics-simulation","title":"Step 4: Write Your Lua Physics Simulation","text":"<p>Now that you've integrated AO-Physics into your project, it's time to write your physics simulation. The AO-Physics library allows you to create and manage physical bodies, simulate interactions, and update the world in a few straightforward steps. Below is an example of how to set up a simple simulation:</p> <pre><code>-- Initialize a new world and create it\nlocal world = AOP:World()\nworld:Create()\n\n-- Create a static floor body with a large size to act as the ground\nlocal floor = AOP:Body()\nfloor.shape = \"Box\" -- Shape of the body\nfloor.size = { 100.0, 1.0, 100.0 } -- Size of the box (length, width, height)\nfloor.motionType = \"Static\" -- The body does not move\nfloor.layer = \"NON_MOVING\" -- Layer for static objects\nfloor.activate = false -- Do not activate this body initially\nfloor:Add() -- Add the body to the world\n\n-- Update the world with a single step\nworld:Update(1, 1/60)\n\n-- Call GetState which updates the World States\nworld:GetState()\n\n-- Print the states of the world after simulation\nprint(world:GetStates())\n\n-- Clean up and destroy the world to free resources\nworld:Destroy()\n</code></pre>"},{"location":"setup/#explanation","title":"Explanation:","text":"<ol> <li>Initialize a World:<ul> <li>First, we initialize a new world using <code>AOP:World()</code>. The <code>Create()</code> function sets up the world, preparing it for simulation.</li> </ul> </li> <li>Create a Static Floor:<ul> <li>We then create a static floor using <code>AOP:Body()</code>. This body has a box shape and a large size to serve as the ground in our simulation. Setting <code>motionType</code> to <code>\"Static\"</code> ensures that this body remains stationary. By assigning it to the <code>\"NON_MOVING\"</code> layer and deactivating it initially, we prevent it from interacting with other objects unnecessarily until required.</li> </ul> </li> <li>Update the World:<ul> <li>We simulate the physics world by calling <code>world:Update(1, 1/60)</code>. This function advances the simulation by one step, calculating interactions and updating the state of all objects in the world.</li> </ul> </li> <li>Retrieve and Print the State:<ul> <li>After the simulation step, we retrieve the current state of the world using <code>world:GetStates()</code>, and print it to see the results of our simulation.</li> </ul> </li> <li>Clean Up:<ul> <li>Finally, we destroy the world using <code>world:Destroy()</code> to free up any resources used by the simulation.</li> </ul> </li> </ol> <p>Info</p> <p>This example demonstrates how to set up a simple physics world, create a static body, and run a simulation step. You can build on this foundation to create more complex simulations, adding dynamic bodies, forces, and interactions as needed.</p>"},{"location":"setup/#step-5-build-and-run-your-simulation","title":"Step 5: Build and Run Your Simulation","text":"<p>Once your simulation code is ready, it's time to build it. The AO-Physics library comes with a build command that compiles your Lua scripts into a fully functional physics simulation.</p> <p>Run the following command in your terminal:</p> <pre><code>ao build\n</code></pre> <p>Info</p> <p>This command will compile your project, incorporating the AO-Physics library. If everything is set up correctly, you should see a message indicating a successful build.</p> <p>Congratulations! You\u2019ve successfully created a physics simulation using AO-Physics. You can now run your simulation and observe the physics interactions you\u2019ve programmed.</p> <p>Checkout out the Unity Renderer for more information on rendering your simulation.</p> <p>By following these steps, you\u2019ll be able to easily set up and use the AO-Physics library in your Lua projects. Whether you\u2019re creating simple physics experiments or complex simulations, AO-Physics provides the tools you need to bring your ideas to life.</p>"},{"location":"unity_renderer/","title":"Unity Renderer","text":""},{"location":"unity_renderer/#overview","title":"Overview","text":"<p>The <code>ParseWorldState</code> script is a Unity component designed to load and visualize the state of a physics simulation from a JSON file. It parses a sequence of world states, each containing information about bodies and constraints, and creates corresponding GameObjects in Unity to represent these elements. This script is particularly useful for visualizing physics simulations or other dynamic systems described by JSON data.</p>"},{"location":"unity_renderer/#features","title":"Features","text":"<ul> <li>JSON Parsing: Reads a JSON file containing world states and converts them into Unity GameObjects.</li> <li>Dynamic Visualization: Supports various primitive shapes like boxes, spheres, capsules, and cylinders to represent different bodies in the simulation.</li> <li>Constraint Handling: Visualizes constraints between bodies using spherical markers and draws lines between connected bodies.</li> <li>Custom Materials: Applies HDRP materials with customizable normal and albedo maps to the bodies and constraints for better visualization.</li> <li>Frame Control: Allows control over the simulation frame rate using a configurable <code>deltaTime</code> parameter.</li> <li>Reset Functionality: Easily reset and reload the simulation using a key press.</li> </ul>"},{"location":"unity_renderer/#installation","title":"Installation","text":"<ol> <li>Add Script to Unity Project:<ul> <li>Copy the <code>ParseWorldState</code> script into your Unity project's <code>Assets/Scripts</code> directory.</li> <li>Attach the <code>ParseWorldState</code> script to a GameObject in your Unity scene.</li> </ul> </li> <li>Prepare JSON File<ul> <li>Ensure that the JSON file describing the world states is accessible from your Unity environment.</li> <li>Update the file path in the script to point to your JSON file location.</li> </ul> </li> <li>Configure Materials:<ul> <li>Set the <code>bodyMaterial</code> and <code>constraintMaterial</code> fields in the Unity Inspector to your desired URP materials.</li> <li>Optionally, assign textures to <code>normalMap</code> and <code>albedoMap</code> fields for enhanced visual effects.</li> </ul> </li> </ol> Here are the normal map and albedo map that I used."},{"location":"unity_renderer/#usage","title":"Usage","text":""},{"location":"unity_renderer/#json-file-structure","title":"JSON File Structure","text":"<p>The JSON file must follow a specific structure to be parsed correctly by the script:</p> World_States.json <p>The AOP Lua Module's <code>World:GetStates()</code> will output the world states in this format.</p> <pre><code>{\n  \"worldStates\": [\n    {\n      \"bodies\": [\n        {\n          \"id\": 1,\n          \"motion_type\": \"dynamic\",\n          \"position\": [0.0, 1.0, 0.0],\n          \"radius\": 1.0,\n          \"height\": 2.0,\n          \"shape\": \"Capsule\",\n          \"size\": [1.0, 2.0, 1.0],\n          \"rotation\": [0.0, 0.0, 0.0, 1.0],\n          \"data\": \"\"\n        }\n      ],\n      \"constraints\": [\n        {\n          \"id\": 1,\n          \"body1ID\": 1,\n          \"body2ID\": 2,\n          \"type\": \"fixed\",\n          \"space\": 0,\n          \"point1\": [0.0, 1.0, 0.0],\n          \"point2\": [1.0, 1.0, 0.0]\n        }\n      ]\n    }\n  ]\n}\n</code></pre>"},{"location":"unity_renderer/#script-parameters","title":"Script Parameters","text":"<ul> <li>deltaTime: Controls the delay between frames. Adjust this to control the speed of the simulation.</li> <li>normalMap: Texture to be applied as a normal map to the body materials.</li> <li>albedoMap: Texture to be applied as an albedo map to the body materials.</li> <li>bodyMaterial: Base material used for the bodies.</li> <li>constraintMaterial: Base material used for the constraints.</li> </ul>"},{"location":"unity_renderer/#running-the-simulation","title":"Running the Simulation","text":"<ol> <li> <p>Start the Simulation:</p> <ul> <li>The simulation begins automatically when the scene is played.</li> <li>The script parses the JSON file, creating and positioning the GameObjects based on the data.</li> </ul> </li> <li> <p>Resetting the Simulation:</p> <ul> <li>Press the <code>Space</code> key to clear the current simulation and reload it from the JSON file.</li> </ul> </li> </ol>"},{"location":"unity_renderer/#customization","title":"Customization","text":"<ul> <li>Shapes: Extend the <code>CreateGameObject</code> method to add more primitive shapes or custom models.</li> <li>Materials: Modify the <code>SetupBodyMaterial</code> method to further customize the appearance of bodies using additional material properties.</li> </ul>"},{"location":"unity_renderer/#conclusion","title":"Conclusion","text":"<p>The <code>ParseWorldState</code> script is a powerful tool for visualizing complex simulations described in JSON format within Unity. It allows for dynamic and customizable visualization, making it ideal for a variety of simulation-based projects.</p>"},{"location":"unity_renderer/#resources","title":"Resources","text":"ParseWorldState.cs <pre><code>using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing System.IO;\n\n[System.Serializable]\npublic class WorldState\n{\n    public List&lt;Body&gt; bodies;\n    public List&lt;Constraint&gt; constraints;\n}\n\n[System.Serializable]\npublic class Body\n{\n    public int id;\n    public string motion_type;\n    public float[] position;\n    public float radius;\n    public float height;\n    public string shape;\n    public float[] size;\n    public float[] rotation;\n    public string data;\n}\n\n[System.Serializable]\npublic class Constraint\n{\n    public int id;\n    public int body1ID;\n    public int body2ID;\n    public string type;\n    public int space;\n    public float[] point1;\n    public float[] point2;\n    public GameObject point1_obj;\n    public GameObject point2_obj;\n}\n\n[System.Serializable]\npublic class Root\n{\n    public List&lt;WorldState&gt; worldStates;\n}\n\npublic class ParseWorldState : MonoBehaviour\n{\n    public float deltaTime;\n\n    public Texture2D normalMap;\n    public Texture2D albedoMap;\n\n    public Material bodyMaterial;\n    public Material constraintMaterial;\n\n    private Dictionary&lt;int, Constraint&gt; constraints = new Dictionary&lt;int, Constraint&gt;();\n    private Dictionary&lt;int, GameObject&gt; bodies = new Dictionary&lt;int, GameObject&gt;();\n\n    // List of colors to use for materials\n    private readonly List&lt;Color&gt; colors = new List&lt;Color&gt;\n    {\n        new Color(0.4f, 0.4f, 0.4f),\n        new Color(1.0f, 0.0f, 0.0f),\n        new Color(0.0f, 1.0f, 0.0f),\n        new Color(0.0f, 0.0f, 1.0f),\n        new Color(1.0f, 1.0f, 0.0f),\n        new Color(1.0f, 0.0f, 1.0f),\n        new Color(0.0f, 1.0f, 1.0f),\n        new Color(1.0f, 1.0f, 1.0f),\n        new Color(0.5f, 0.5f, 0.5f),\n        new Color(0.5f, 0.5f, 0.0f)\n    };\n\n    // Coroutine to parse and display the world states\n    private IEnumerator Start()\n    {\n        int frame = 0;\n\n        // Read and parse the JSON file\n        string jsonString = File.ReadAllText(\"[[ file of the worldstates json ]]\");\n        Root root = JsonUtility.FromJson&lt;Root&gt;(jsonString);\n\n        // Iterate through each world state in the JSON\n        foreach (var worldState in root.worldStates)\n        {\n            // Handle each body in the world state\n            foreach (Body body in worldState.bodies)\n            {\n                GameObject obj = null;\n\n                if (!bodies.ContainsKey(body.id))\n                {\n                    // Create a GameObject based on the shape type\n                    obj = CreateGameObject(body);\n\n                    // Set up the material for the body\n                    SetupBodyMaterial(obj, body);\n\n                    // Add the body to the dictionary\n                    bodies.Add(body.id, obj);\n                }\n                else\n                {\n                    // Retrieve the existing GameObject\n                    obj = bodies[body.id];\n                }\n\n                // Update the transform and scale of the GameObject\n                UpdateTransform(obj, body);\n            }\n\n            // Destroy any bodies that are no longer present in the world state\n            DestroyAbsentBodies(worldState);\n\n            // Handle each constraint in the world state\n            foreach (Constraint constraint in worldState.constraints)\n            {\n                if (!constraints.ContainsKey(constraint.id))\n                {\n                    // Create GameObjects for the constraint points\n                    SetupConstraintPoints(constraint);\n\n                    // Add the constraint to the dictionary\n                    constraints.Add(constraint.id, constraint);\n                }\n            }\n\n            // Increment the frame count and wait for the next update\n            frame++;\n            yield return new WaitForSeconds(frame == 1 ? 2 : deltaTime);\n        }\n\n        yield return null;\n    }\n\n    // Creates a GameObject based on the body's shape\n    private GameObject CreateGameObject(Body body)\n    {\n        GameObject obj = body.shape switch\n        {\n            \"Box\" =&gt; GameObject.CreatePrimitive(PrimitiveType.Cube),\n            \"Sphere\" =&gt; GameObject.CreatePrimitive(PrimitiveType.Sphere),\n            \"Capsule\" =&gt; GameObject.CreatePrimitive(PrimitiveType.Capsule),\n            \"Cylinder\" =&gt; GameObject.CreatePrimitive(PrimitiveType.Cylinder),\n            _ =&gt; null\n        };\n\n        return obj;\n    }\n\n    // Sets up the material for the body GameObject\n    private void SetupBodyMaterial(GameObject obj, Body body)\n    {\n        Material material = new Material(bodyMaterial)\n        {\n            mainTextureScale = new Vector2(body.size[0], body.size[2])\n        };\n\n        material.SetTexture(\"_BaseColorMap\", albedoMap);\n        material.SetTexture(\"_NormalMap\", normalMap);\n\n        // Assign a color from the predefined list\n        Color color = colors[bodies.Count % colors.Count];\n        material.SetColor(\"_BaseColor\", color);\n\n        obj.GetComponent&lt;MeshRenderer&gt;().material = material;\n    }\n\n    // Updates the position, rotation, and scale of the body GameObject\n    private void UpdateTransform(GameObject obj, Body body)\n    {\n        obj.transform.SetPositionAndRotation(\n            new Vector3(body.position[0], body.position[1], body.position[2]),\n            new Quaternion(body.rotation[0], body.rotation[1], body.rotation[2], body.rotation[3])\n        );\n\n        if (body.shape == \"Capsule\" || body.shape == \"Cylinder\")\n        {\n            obj.transform.localScale = new Vector3(body.radius * 2, body.height * 0.5f, body.radius * 2);\n        }\n        else\n        {\n            obj.transform.localScale = new Vector3(body.size[0], body.size[1], body.size[2]);\n        }\n    }\n\n    // Destroys bodies that are not present in the current world state\n    private void DestroyAbsentBodies(WorldState worldState)\n    {\n        List&lt;int&gt; toDestroy = new List&lt;int&gt;();\n\n        foreach (int id in bodies.Keys)\n        {\n            if (worldState.bodies.Find(x =&gt; x.id == id) == null)\n            {\n                toDestroy.Add(id);\n            }\n        }\n\n        foreach (int id in toDestroy)\n        {\n            Destroy(bodies[id]);\n            bodies.Remove(id);\n        }\n    }\n\n    // Sets up the constraint points as GameObjects\n    private void SetupConstraintPoints(Constraint constraint)\n    {\n        constraint.point1_obj = CreateConstraintPoint();\n        constraint.point2_obj = CreateConstraintPoint();\n\n        if (constraint.space == 0 || constraint.space == 1)\n        {\n            constraint.point1_obj.transform.parent = bodies[constraint.body1ID].transform;\n            constraint.point2_obj.transform.parent = bodies[constraint.body2ID].transform;\n        }\n\n        constraint.point1_obj.transform.position = new Vector3(constraint.point1[0], constraint.point1[1], constraint.point1[2]);\n        constraint.point2_obj.transform.position = new Vector3(constraint.point2[0], constraint.point2[1], constraint.point2[2]);\n    }\n\n    // Creates a spherical GameObject for a constraint point\n    private GameObject CreateConstraintPoint()\n    {\n        GameObject pointObj = GameObject.CreatePrimitive(PrimitiveType.Sphere);\n        Material material = new Material(constraintMaterial);\n        pointObj.GetComponent&lt;MeshRenderer&gt;().material = material;\n        pointObj.transform.localScale = new Vector3(0.35f, 0.35f, 0.35f);\n        return pointObj;\n    }\n\n    // Update is called once per frame\n    private void Update()\n    {\n        // Draws lines between the constraint points\n        foreach (Constraint constraint in constraints.Values)\n        {\n            GameObject obj1 = bodies[constraint.body1ID];\n            GameObject obj2 = bodies[constraint.body2ID];\n\n            Debug.DrawLine(obj1.transform.position, obj2.transform.position, Color.green);\n        }\n\n        // Resets the simulation on space key press\n        if (Input.GetKeyDown(KeyCode.Space))\n        {\n            ResetSimulation();\n        }\n    }\n\n    // Resets the simulation by clearing bodies and constraints\n    private void ResetSimulation()\n    {\n        constraints.Clear();\n\n        foreach (GameObject obj in bodies.Values)\n        {\n            Destroy(obj);\n        }\n\n        foreach (Constraint constraint in constraints.Values)\n        {\n            Destroy(constraint.point1_obj);\n            Destroy(constraint.point2_obj);\n        }\n\n        bodies.Clear();\n        StopAllCoroutines();\n        StartCoroutine(Start());\n    }\n}\n</code></pre>"},{"location":"world/","title":"World","text":"<p>The <code>World</code> class represents the entire simulation environment, handling physical interactions and managing the state of the simulation.</p>"},{"location":"world/#properties","title":"Properties","text":"Property Type Description Default Value <code>gravity</code> <code>table</code> The gravitational force affecting the world. <code>{ 0.0, -9.81, 0.0 }</code> <code>timeBeforeSleep</code> <code>number</code> Time before bodies go to sleep. <code>0.5</code> <code>allowSleeping</code> <code>boolean</code> Whether bodies are allowed to sleep when inactive. <code>true</code> <code>maxBodies</code> <code>number</code> Maximum number of bodies in the world. <code>1024</code> <code>numBodyMutexes</code> <code>number</code> Number of mutexes used for body operations. <code>0</code> <code>maxBodyPairs</code> <code>number</code> Maximum number of body pairs for collision detection. <code>1024</code> <code>maxContactConstraints</code> <code>number</code> Maximum number of contact constraints. <code>1024</code>"},{"location":"world/#functions","title":"Functions","text":""},{"location":"world/#create","title":"Create","text":"DetailsExample <p>Initializes the world with the specified settings.</p> <pre><code>local world = AOP:World()\nworld:Create()\n</code></pre>"},{"location":"world/#update","title":"Update","text":"DetailsParametersExample <p>Updates the world simulation by a specified number of steps and time delta.</p> <ul> <li><code>steps</code> (<code>number</code>): The number of simulation steps to advance.</li> <li><code>deltaTime</code> (<code>number</code>): The time increment for each simulation step.</li> </ul> <pre><code>world:Update(1, 0.016)\n</code></pre>"},{"location":"world/#getstate","title":"GetState","text":"DetailsReturnsExample <p>Retrieves the current state of the world.</p> <ul> <li><code>state</code> (<code>table</code>): The current state of the world.</li> </ul> <pre><code>local state = world:GetState()\nprint(state)\n</code></pre>"},{"location":"world/#getstates","title":"GetStates","text":"DetailsReturnsExample <p>Retrieves the history of world states since the last call.</p> <ul> <li><code>stateHistory</code> (<code>string</code>): A JSON string representing the history of world states.</li> </ul> <pre><code>local stateHistory = world:GetStates()\nprint(stateHistory)\n</code></pre>"},{"location":"world/#destroy","title":"Destroy","text":"DetailsExample <p>Destroys the world, cleaning up resources and ending the simulation.</p> <pre><code>world:Destroy()\n</code></pre>"},{"location":"world/#example","title":"Example","text":"<p>This example demonstrates how to create a world, configure its properties, and update its simulation.</p>"},{"location":"world/#code","title":"Code","text":"<pre><code>local world = AOP:World()              -- Create a new world instance.\nworld.gravity = {0.0, -9.81, 0.0}     -- Set gravity to Earth's gravity.\nworld.timeBeforeSleep = 1.0           -- Set time before bodies go to sleep to 1 second.\nworld.maxBodies = 2048                -- Set maximum number of bodies to 2048.\nworld:Create()                       -- Initialize the world with these settings.\n\nworld:Update(1, 0.016)               -- Advance the simulation by one step (0.016 seconds).\n\nlocal currentState = world:GetState()  -- Retrieve the current state of the world.\nprint(\"Current State:\", currentState)\n\nlocal stateHistory = world:GetStates()  -- Retrieve and clear the history of world states.\nprint(\"State History:\", stateHistory)\n\nworld:Destroy()                       -- Destroy the world and clean up resources.\n</code></pre>"},{"location":"world/#description","title":"Description","text":"<ul> <li>Create a World Instance: <code>AOP:World()</code> creates a new world instance with default settings.</li> <li>Set Properties: Modify properties such as <code>gravity</code>, <code>timeBeforeSleep</code>, and <code>maxBodies</code> to configure the world.</li> <li>Initialize World: The <code>Create</code> method is used to initialize the world with the configured settings.</li> <li>Advance Simulation: The <code>Update</code> method advances the simulation by one step, updating the world state.</li> <li>Retrieve Current State: The <code>GetState</code> method retrieves the current state of the world.</li> <li>Retrieve State History: The <code>GetStates</code> method retrieves and clears the history of world states.</li> <li>Destroy World: The <code>Destroy</code> method is used to clean up resources and end the simulation.</li> </ul>"},{"location":"examples/basic/","title":"Basic Example","text":"<p>This example demonstrates how to create and manage a simple simulation using AO Physics in Lua. The script sets up a world, creates multiple physical bodies with different properties and interactions, and then runs a simulation for a specified number of frames.</p>"},{"location":"examples/basic/#code-overview","title":"Code Overview","text":"<pre><code>-- Load the AO Physics library\nAOP = require(\"AOP\")\n\n-- Define the number of simulation frames and the time step for each frame\nlocal framesToSimulate = 1000\nlocal deltaTime = 1.0 / 60.0\n\n--- Create a World ---\n-- Initialize a new world and create it\nlocal world = AOP:World()\nworld:Create()\n\n--- Create a Floor ---\n-- Create a static floor body with a large size to act as the ground\nlocal floor = AOP:Body()\nfloor.shape = \"Box\" -- Shape of the body\nfloor.size = { 100.0, 1.0, 100.0 } -- Size of the box (length, width, height)\nfloor.motionType = \"Static\" -- The body does not move\nfloor.layer = \"NON_MOVING\" -- Layer for static objects\nfloor.activate = false -- Do not activate this body initially\nfloor:Add() -- Add the body to the world\n\n-- Create a dynamic sphere body and set its initial linear velocity\nlocal sphere = AOP:Body()\nsphere.shape = \"Sphere\" -- Shape of the body\nsphere.radius = 0.5 -- Radius of the sphere\nsphere.position = { -3.0, 1, 0.0 } -- Initial position of the sphere (x, y, z)\nsphere:Add() -- Add the body to the world\nsphere:SetLinearVelocity({ 0.0, 0.0, 5.0 }) -- Set the initial linear velocity\n\n-- Create another dynamic sphere body and apply a force\nlocal sphere2 = AOP:Body()\nsphere2.shape = \"Sphere\" -- Shape of the body\nsphere2.radius = 0.5 -- Radius of the sphere\nsphere2.position = { -1.0, 1, 0.0 } -- Initial position of the sphere\nsphere2:Add() -- Add the body to the world\nsphere2:AddForce({ 0.0, 0.0, 100000.0 }) -- Apply a force to the sphere\n\n-- Create a third dynamic sphere body and apply an impulse\nlocal sphere3 = AOP:Body()\nsphere3.shape = \"Sphere\" -- Shape of the body\nsphere3.radius = 0.5 -- Radius of the sphere\nsphere3.position = { 1.0, 1, 0.0 } -- Initial position of the sphere\nsphere3:Add() -- Add the body to the world\nsphere3:AddImpulse({ 0.0, 0.0, 1500.0 }) -- Apply an impulse to the sphere\n\n-- Create a fourth dynamic sphere body and apply torque\nlocal sphere4 = AOP:Body()\nsphere4.shape = \"Sphere\" -- Shape of the body\nsphere4.radius = 0.5 -- Radius of the sphere\nsphere4.position = { 3.0, 1, 0.0 } -- Initial position of the sphere\nsphere4:Add() -- Add the body to the world\nsphere4:AddTorque({ 50000.0, 0.0, 0 }) -- Apply torque to the sphere\n\n--- Update the World ---\n-- Simulate the world for the specified number of frames\nfor i = 1, framesToSimulate do\n    world:Update(1, deltaTime) -- Update the world with a single step\n    world:GetState() -- Get the current state of the world\nend\n\n--- Get World States ---\n-- Print the states of the world after simulation\nprint(world:GetStates())\n\n--- Destroy the World ---\n-- Clean up and destroy the world to free resources\nworld:Destroy()\n\n-- Return\nreturn \"\"\n</code></pre>"},{"location":"examples/basic/#step-by-step-breakdown","title":"Step-by-Step Breakdown","text":"<p>Load the AO Physics Library: <pre><code>AOP = require(\"AOP\")\n</code></pre></p> <p>Define Simulation Parameters: <pre><code>local framesToSimulate = 1000\nlocal deltaTime = 1.0 / 60.0\n</code></pre></p> <p>Create a World: <pre><code>local world = AOP:World()\nworld:Create()\n</code></pre></p> <p>Create a Static Floor: <pre><code>-- Create a static floor body with a large size to act as the ground\nlocal floor = AOP:Body() -- Create a new body object\nfloor.shape = \"Box\" -- Set the shape of the body to a box\nfloor.size = { 100.0, 1.0, 100.0 } -- Set the size of the box (length, width, height)\nfloor.motionType = \"Static\" -- Set the motion type of the body to static (does not move)\nfloor.layer = \"NON_MOVING\" -- Set the layer of the body to NON_MOVING\nfloor.activate = false -- Set the activation state of the body to false (do not activate initially)\nfloor:Add() -- Add the body to the world\n</code></pre></p> <p>Create and Configure Multiple Spheres:</p> <pre><code>local sphere = AOP:Body() -- Create a new body object\nsphere.shape = \"Sphere\" -- Set the shape of the body to a sphere\nsphere.radius = 0.5 -- Set the radius of the sphere\nsphere.position = { -3.0, 1, 0.0 } -- Set the initial position of the sphere (x, y, z)\nsphere:Add() -- Add the body to the world\nsphere:SetLinearVelocity({ 0.0, 0.0, 5.0 }) -- Set the initial linear velocity of the sphere\n\nlocal sphere2 = AOP:Body() -- Create a new body object for sphere2\nsphere2.shape = \"Sphere\" -- Set the shape of sphere2 to a sphere\nsphere2.radius = 0.5 -- Set the radius of sphere2 to 0.5\nsphere2.position = { -1.0, 1, 0.0 } -- Set the initial position of sphere2 to (-1.0, 1, 0.0)\nsphere2:Add() -- Add sphere2 to the world\nsphere2:AddForce({ 0.0, 0.0, 100000.0 }) -- Apply a force of (0.0, 0.0, 100000.0) to sphere2\n\nlocal sphere3 = AOP:Body() -- Create a new body object for sphere3\nsphere3.shape = \"Sphere\" -- Set the shape of sphere3 to a sphere\nsphere3.radius = 0.5 -- Set the radius of sphere3 to 0.5\nsphere3.position = { 1.0, 1, 0.0 } -- Set the initial position of sphere3 to (1.0, 1, 0.0)\nsphere3:Add() -- Add sphere3 to the world\nsphere3:AddImpulse({ 0.0, 0.0, 1500.0 }) -- Apply an impulse of (0.0, 0.0, 1500.0) to sphere3\n\nlocal sphere4 = AOP:Body() -- Create a new body object for sphere4\nsphere4.shape = \"Sphere\" -- Set the shape of sphere4 to a sphere\nsphere4.radius = 0.5 -- Set the radius of sphere4 to 0.5\nsphere4.position = { 3.0, 1, 0.0 } -- Set the initial position of sphere4 to (3.0, 1, 0.0)\nsphere4:Add() -- Add sphere4 to the world\nsphere4:AddTorque({ 50000.0, 0.0, 0 }) -- Apply a torque of (50000.0, 0.0, 0) to sphere4\n</code></pre> <p>Run the Simulation: <pre><code>for i = 1, framesToSimulate do\n    world:Update(1, deltaTime) -- Update the world with a single step\n    world:GetState() -- Get the current state of the world\nend\n</code></pre></p> <p>Output World States and Clean Up: <pre><code>-- Print the states of the world after simulation\nprint(world:GetStates())\n\n-- Clean up and destroy the world to free resources\nworld:Destroy()\n</code></pre></p>"},{"location":"examples/basic/#notes","title":"Notes","text":"<ul> <li>This script initializes a world and several physical bodies with different properties and forces.</li> <li>It simulates the world for 1000 frames, printing the world state after each frame.</li> <li>The simulation environment is destroyed at the end to clean up resources.</li> </ul> <p>For more details on the AO Physics library and its components, please refer to the AO Physics Documentation.</p>"}]}